rtrans-exists : {E} rtrans E R -> type.
%mode rtrans-exists +E -DT.

rtrans-exists/num : rtrans-exists (num N) rtrans/num.

rtrans-exists/lam : rtrans-exists (lam E) (rtrans/lam DT)
                     <- {x} {y} {dt} rtrans-exists x dt -> rtrans-exists (E x) (DT x y dt).

rtrans-exists/app : rtrans-exists (app E1 E2) (rtrans/app DT2 DT1)
                     <- rtrans-exists E1 DT1
                     <- rtrans-exists E2 DT2.

%block bl-rtrans-exists : block {x : exp} {y : var} {dt : rtrans x (rvar y)} {pf : rtrans-exists x dt}.

%worlds (bl-rtrans-exists) (rtrans-exists _ _).
%total E (rtrans-exists E _).



% Notion of an expression being closed under a given environment.
closed : venv -> exp -> type.

closed/num : closed Delta (num N).

closed/var : closed Delta E
              <- trans-var Delta E I.

closed/lam : closed Delta (lam [x] E x)
              <- {x} closed (venv/cons Delta x) (E x).

closed/app : closed Delta (app E1 E2)
              <- closed Delta E1
              <- closed Delta E2.



% Totality of translation for closed terms.
trans-exists : closed Delta E -> trans Delta E B -> type.
%mode trans-exists +DC -DT.

trans-exists/num : trans-exists closed/num trans/num.

trans-exists/var : trans-exists (closed/var DTV) (trans/var DTV).

trans-exists/lam : trans-exists (closed/lam DC) (trans/lam DT)
                    <- {x} trans-exists (DC x) (DT x).

trans-exists/app : trans-exists (closed/app DC2 DC1) (trans/app DT2 DT1)
                    <- trans-exists DC1 DT1
                    <- trans-exists DC2 DT2.

%worlds (bl-exp) (trans-exists _ _).
%total DC (trans-exists DC _).



% It would be nice to prove (in the empty LF context):

empty-trans-exists : {E} trans venv/nil E B -> type.

% To do that we would need:

closed-exists : {E} closed venv/nil E -> type.

% However, encoding the invariant that all lambda-bound variables occur somewhere in delta seems troublesome.
% One line of attack is to define a version of 'closed' using an implicit environment, thus:

iclosed : exp -> type.
%mode iclosed +E.

iclosed/num : iclosed (num N).

iclosed/lam : iclosed (lam [x] E x)
               <- {x} iclosed (E x)
                       <- iclosed x.

iclosed/app : iclosed (app E1 E2)
               <- iclosed E1
               <- iclosed E2.

%block bl-iclosed : block {x : exp} {c : iclosed x}.
%worlds (bl-iclosed) (iclosed _).
%total E (iclosed E).

% This version is observed to be total, so the problem is now "reduced" to showing:

iclosed-to-closed : iclosed E -> closed venv/nil E -> type.

% However, there are still issues relating objects in the implicit context with objects in the explicit context.
% Indeed, it is not even clear what the induction hypothesis should be.
