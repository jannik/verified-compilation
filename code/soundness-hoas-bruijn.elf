cor : value -> exp -> type. %name cor DC.
comp : store -> venv -> map -> type. %name comp DD.

cor/num : cor (vnum N) (num N).

cor/fun : {E} {Delta} {Phi} cor (vclos Sigma B) (lam [x] E' x)
           <- ({x} local x -> subst Phi (E x) (E' x))
           <- comp Sigma Delta Phi
           <- ({x} trans-hb (venv/cons Delta x) (E x) B).

cor/local : cor B E
             <- (exp -> cor B E).

comp/nil : comp store/nil venv/nil map/nil.

comp/cons : comp (store/cons Sigma V) (venv/cons Delta X) (map/cons Phi X C)
             <- comp Sigma Delta Phi
             <- cor V C.



left-to-right-var : trans-hb-var Delta X I -> lookup Phi X C -> comp Sigma Delta Phi
                 -> beval-var Sigma I V -> cor V C -> type.
%mode left-to-right-var +DTV +DL +DD -DBV -DC.

left-to-right-var/here : left-to-right-var trans-hb-var/here lookup/here (comp/cons DC DD1) beval-var/here DC.

% missing here-there case
% probably need the requirement X /= Y in 'there' rules..

left-to-right-var/there : left-to-right-var (trans-hb-var/there DTV1) (lookup/there DL1) (comp/cons DC DD1)
                           (beval-var/there DBV1) DC1
                           <- left-to-right-var DTV1 DL1 DD1 DBV1 DC1.

% missing there-here case

%worlds (bl-exp) (left-to-right-var _ _ _ _ _).
% total (DTV) (left-to-right-var DTV _ _ _ _).



left-to-right : trans-hb Delta E B -> subst Phi E E' -> eval E' C -> comp Sigma Delta Phi
             -> beval Sigma B V -> cor V C -> type.
%mode left-to-right +DT +DS +DE +DD -DB -DC.

left-to-right/num : left-to-right trans-hb/num subst/num eval/num DD beval/num cor/num.

left-to-right/var : left-to-right (trans-hb/var DTV) (subst/var DL) DE DD (beval/var DBV) DC
                     <- left-to-right-var DTV DL DD DBV DC.

left-to-right/lam : left-to-right
                     (trans-hb/lam (DT : {x} trans-hb (venv/cons Delta x) (E1 x) B1))
                     (subst/lam DS)
                     eval/lam
                     (DD : comp Sigma Delta Phi)
                     beval/lam
                     (cor/fun E1 Delta Phi DT DD DS).

left-to-right/app : left-to-right
                     (trans-hb/app (DT2 : trans-hb Delta E2 B2) (DT1 : trans-hb Delta E1 B1))
                     (subst/app (DS2 : subst Phi E2 E2') (DS1 : subst Phi E1 E1'))
                     (eval/app (DE3 : eval (E0' C2) C) (DE2 : eval E2' C2) (DE1 : eval E1' (lam E0')))
                     (DD : comp Sigma Delta Phi)
                     (beval/app DB3 DB2 DB1)
                     DC
                     <- left-to-right DT1 DS1 DE1 DD DB1 (cor/fun _ Delta' Phi' DT1' DD1' DS1')
                     <- left-to-right DT2 DS2 DE2 DD DB2 DC2
                     <- ({x} {l} subst-append E0 E0' C2 (DS1' x l) (DS1'' x))
                     <- {x}  left-to-right (DT1' x) (DS1'' x) DE3 (comp/cons DC2 DD1') DB3 DC.

%worlds (bl-exp) (left-to-right _ _ _ _ _ _).
% total DE (left-to-right _ _ DE _ _ _).



soundness-ltr : trans-hb venv/nil E B -> eval E (num N) -> beval store/nil B (vnum N) -> cor V C -> type.
%mode soundness-ltr +DT +DE -DB -DC.

- : soundness-ltr (DT : trans-hb venv/nil E B) DE DB DC
     <- empty-subst E DS
     <- left-to-right DT DS DE comp/nil DB DC.

%worlds () (soundness-ltr _ _ _ _).
%covers soundness-ltr +DT +DE -DB -DC.
% total {} (soundness-ltr _ _ _ _).



eval-canon : canon C -> eval C C -> type.
%mode eval-canon +DC -DE.

eval-canon/num : eval-canon canon/num eval/num.

eval-canon/lam : eval-canon canon/lam eval/lam.

%worlds () (eval-canon _ _).
%total (DC) (eval-canon DC _).



right-to-left-var : trans-hb-var Delta X I -> beval-var Sigma I V -> lookup Phi X C -> comp Sigma Delta Phi
                 -> cor V C -> type.
%mode right-to-left-var +DTV +DBV +DL +DD -DC.

% missing cases

%worlds (bl-exp) (right-to-left-var _ _ _ _ _).
% total (DTV) (right-to-left-var DTV _ _ _ _).



right-to-left : trans-hb Delta E B -> subst Phi E E' -> beval Sigma B V -> comp Sigma Delta Phi
             -> eval E' C -> cor V C -> type.
%mode right-to-left +DT +DS +DB +DD -DE -DC.

right-to-left/num : right-to-left trans-hb/num subst/num beval/num DD eval/num cor/num.

% need to change definition of map (Phi) such that it maps to canonical forms

% right-to-left/var : right-to-left (trans-hb/var DTV) (subst/var DL) (beval/var DBV) DD DE DC
%                      <- right-to-left-var DTV DBV DL DD DC
%                      <- % must have 'canon C' and use eval-canon to get DE.

%worlds (bl-exp) (right-to-left _ _ _ _ _ _).
% total DB (right-to-left _ _ DB _ _ _).



soundness-rtl : trans-hb venv/nil E B -> beval store/nil B (vnum N) -> eval E (num N) -> cor V C -> type.
%mode soundness-rtl +DT +DB -DE -DC.

- : soundness-rtl (DT : trans-hb venv/nil E B) DB DE DC
     <- empty-subst E DS
     <- right-to-left DT DS DB comp/nil DE DC.

%worlds () (soundness-rtl _ _ _ _).
%covers soundness-rtl +DT +DB -DE -DC.
% total {} (soundness-rtl _ _ _ _).
