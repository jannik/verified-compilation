%%% Phenning's implementation, adapted to our definition of the source language.



exp' : type. %name exp' F f.

1 : exp'.
^ : exp' -> exp'. %postfix 20 ^.
num' : nat -> exp'.
lam' : exp' -> exp'.
app' : exp' -> exp' -> exp'.



% Environments and values

env : type. %name env N.
val : type. %name val W w.

empty : env.
, : env -> val -> env. %infix left 10 ,.

const : nat -> val.
clo : env -> exp' -> val.



feval : env -> exp' -> val -> type. %name feval D'.
%mode feval +N +F -W.

% Variables

fev/1 : feval (N , W) 1 W.

fev/^ : feval (N , W') (F ^) W
         <- feval N F W.

% Constants

fev/num : feval N (num' K) (const K).

% Functions

fev/lam : feval N (lam' F) (clo N (lam' F)).

fev/app : feval N (app' F1 F2) W
           <- feval N F1 (clo N' (lam' F1'))
           <- feval N F2 W2
           <- feval (N' , W2) F1' W.



%query 1 5 D : feval empty (app' (lam' (lam' (1 ^))) (lam' 1)) W.



trans : env -> exp' -> exp -> type. %name trans C.
vtrans : val -> exp -> type. %name vtrans U.
% can be used in different directions
%mode trans +N +F -E.
%mode vtrans +W -V.

% Constants

tr/num : trans N (num' K) (num K).

% Functions

tr/lam : trans N (lam' F) (lam E)
          <- ({w:val} {x:exp}
                vtrans w x -> trans (N , w) F (E x)).

tr/app : trans N (app' F1 F2) (app E1 E2)
          <- trans N F1 E1
          <- trans N F2 E2.

% Variables

tr/1 : trans (N , W) 1 E
        <- vtrans W E.

tr/^ : trans (N , W) (F ^) E
        <- trans N F E.

% Values

vtr/num : vtrans (const K) (num K).

vtr/lam : vtrans (clo N (lam' F)) (lam E)
           <- trans N (lam' F) (lam E).



%query 1 5 C : trans empty F (app (lam [x] lam [y] x) (lam [z] z)).



map-eval : eval E V -> trans N F E
             -> feval N F W -> vtrans W V -> type.
%mode map-eval +D +C -D' -U.

mp/1num : map-eval (eval/num) (tr/1 vtr/num) (fev/1) (vtr/num).

mp/1lam : map-eval (eval/lam) (tr/1 (vtr/lam (tr/lam C2)))
                   (fev/1) (vtr/lam (tr/lam C2)).

mp/^ : map-eval D (tr/^ C1) (fev/^ D1') U1
        <- map-eval D C1 D1' U1.

mp/num : map-eval (eval/num) (tr/num) (fev/num) (vtr/num).

mp/lam : map-eval (eval/lam) (tr/lam C1)
                  (fev/lam) (vtr/lam (tr/lam C1)).

mp/app : map-eval (eval/app D3 D2 D1) (tr/app C2 C1)
                  (fev/app D3' D2' D1') U3
          <- map-eval D1 C1 D1' (vtr/lam (tr/lam C3))
          <- map-eval D2 C2 D2' U2
          <- map-eval D3 (C3 W2 V2 U2) D3' U3.

%worlds () (map-eval _ _ _ _).
%total {D C} (map-eval D C _ _).



map-eval' : eval E V -> trans N F E
              -> feval N F W -> vtrans W V -> type.
%mode map-eval' -D +C +D' -U.

mp'/1num : map-eval' (eval/num) (tr/1 vtr/num) (fev/1) (vtr/num).

mp'/1lam : map-eval' (eval/lam) (tr/1 (vtr/lam (tr/lam C2)))
                     (fev/1) (vtr/lam (tr/lam C2)).

mp'/^ : map-eval' D (tr/^ C1) (fev/^ D1') U1
         <- map-eval' D C1 D1' U1.

mp'/num : map-eval' (eval/num) (tr/num) (fev/num) (vtr/num).

mp'/lam : map-eval' (eval/lam) (tr/lam C1)
                    (fev/lam) (vtr/lam (tr/lam C1)).

mp'/app : map-eval' (eval/app D3 D2 D1) (tr/app C2 C1)
                    (fev/app D3' D2' D1') U3
           <- map-eval' D1 C1 D1' (vtr/lam (tr/lam C3))
           <- map-eval' D2 C2 D2' U2
           <- map-eval' D3 (C3 W2 V2 U2) D3' U3.

%worlds () (map-eval' _ _ _ _).
%total D' (map-eval' _ C D' _).
