\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{ntheorem}

\newcommand{\ensurecommand}[1]{\providecommand{#1}{}\renewcommand{#1}}

\newcommand{\tup}[1]{\langle #1 \rangle}
\newcommand{\set}[1]{\{ #1 \}}

\newcommand{\alt}{\;\; | \;\;}
\newcommand{\defi}{\Coloneqq}
%\newcommand{\nil}{\cdot}
\newcommand{\nil}{[]}
\newcommand{\h}[1]{\hat{#1}}
\renewcommand{\rule}{\textsc}
\newcommand{\sg}{\sigma}
\renewcommand{\phi}{\varphi}
\renewcommand{\H}{H}
\newcommand{\De}{\Delta}
\newcommand{\E}{\mathcal{E}}
%\newcommand{\B}{\mathcal{B}}
\newcommand{\Bv}{\mathcal{B}^{\mathrm{v}}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\Tv}{\mathcal{T}^{\mathrm{v}}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\z}{\mathtt{z}}
\newcommand{\suc}{\mathtt{s} \;}
\newcommand{\dom}{\mathsf{dom}}

\newcommand{\n}[1]{\overline{#1}}
\newcommand{\lam}[2]{\lambda #1. #2}
\newcommand{\app}{\;}
\newcommand{\cl}[2]{\{ #1 , #2 \}}
\newcommand{\sub}[3]{#1[#2/#3]}
\newcommand{\subs}[2]{#1[#2]}
\newcommand{\wo}{\backslash}
\newcommand{\sapp}{\mathtt{app}}

\newcommand{\rpaddr}[1]{\mathtt{paddr} \; #1}
\newcommand{\rhaddr}[1]{\mathtt{haddr} \; #1}
\newcommand{\rundef}{\mathtt{undef}}

\newcommand{\mload}[1]{\mathtt{load} \; #1}
\newcommand{\mstore}[1]{\mathtt{store} \; #1}
\newcommand{\malloc}[1]{\mathtt{alloc} \; #1}
\newcommand{\mpeek}[1]{\mathtt{peek} \; #1}
\newcommand{\mpushnum}[1]{\mathtt{pushnum} \; #1}
\newcommand{\mpushpaddr}[1]{\mathtt{pushpaddr} \; #1}
\newcommand{\mnewframe}{\mathtt{newframe}}
\newcommand{\mendframe}{\mathtt{endframe}}
\newcommand{\mgetarg}{\mathtt{getarg}}
\newcommand{\mgetenv}{\mathtt{getenv}}
\newcommand{\mgetret}{\mathtt{getret}}
\newcommand{\mjump}{\mathtt{jump}}
\newcommand{\mgetaddr}[1]{\mathtt{getaddr} \; #1}
\newcommand{\mhalt}{\mathtt{halt}}

\newcommand{\mend}{\mathtt{end}}

\newcommand{\mpushvar}[1]{\mathtt{pushvar} \; #1}
\newcommand{\mpushclos}[1]{\mathtt{pushclos} \; #1}
\newcommand{\mcall}[1]{\mathtt{call} \; #1}
\newcommand{\mret}{\mathtt{ret}}

\newcommand{\lhere}{\mathtt{here}}
\newcommand{\lnext}{\mathtt{next}}
\newcommand{\lleft}{\mathtt{left}}
\newcommand{\lright}{\mathtt{right}}
\newcommand{\ldone}{\mathtt{done}}

\newcommand{\hsuc}[1]{\mathtt{suc} \; #1}
\newcommand{\hcase}[3]{\mathtt{case} \; #1 \; \mathtt{of} \; \z \Rightarrow #2 \; | \; \suc{x} \Rightarrow #3}
\newcommand{\bsuc}[1]{\mathtt{suc} \; #1}
\newcommand{\bcase}[3]{\mathtt{case} \; #1 \; #2 \; #3}
\newcommand{\scase}[2]{\mathtt{case} \; #1 \; #2}

\newcommand{\judgement}[1]{\noindent \framebox{#1}}
\newcommand{\ninf}[1]{\AxiomC{#1}}
\newcommand{\uinf}[1]{\UnaryInfC{#1}}
\newcommand{\binf}[1]{\BinaryInfC{#1}}
\newcommand{\tinf}[1]{\TrinaryInfC{#1}}
\newcommand{\qinf}[1]{\QuaternaryInfC{#1}}
\newcommand{\fiveinf}[1]{\QuinaryInfC{#1}}
\newcommand{\ax}[1]{\ninf{} \uinf{#1}}
\newcommand{\prem}[2]{\noLine \ninf{$#1$} \uinf{#2}}
\newcommand{\leftl}[1]{\LeftLabel{#1\;}}
\newcommand{\rightl}[1]{\RightLabel{#1}}

\newcommand{\tr}[2]{\ensuremath{#1 \rhd #2}}
\newcommand{\tracc}[3]{\ensuremath{#1 \circ #2 \rhd #3}}
\newcommand{\tra}[4]{\ensuremath{#1; #2 \vdash #3 \rhd #4}}
\newcommand{\trm}[6]{\ensuremath{#1 \vdash \langle #2; #3 \rangle \circ #4 \rhd \langle #5; #6 \rangle}}
\newcommand{\ev}[2]{\ensuremath{#1 \downarrow #2}}
\newcommand{\hev}[3]{\ensuremath{#1 \vdash #2 \Downarrow #3}}
\newcommand{\hevv}[3]{\ensuremath{#1 \vdash #2 \Downarrow^{\mathrm{v}} #3}}
\newcommand{\sev}[4]{\ensuremath{\langle #1; #2 \rangle \rightarrow \langle #3; #4 \rangle}}
\newcommand{\ssev}[4]{\ensuremath{\langle #1; #2 \rangle \rightarrow^* \langle #3; #4 \rangle}}
\newcommand{\sevv}[3]{\ensuremath{#1 \vdash #2 \downarrow^{\mathrm{v}} #3}}

\newcommand{\meval}[3]{\ensuremath{\langle #1; #2 \rangle \downarrow #3}}
\newcommand{\mev}[9]{\ensuremath{#1 \vdash \langle #2; #3; #4; #5 \rangle \rightarrow \langle #6; #7; #8; #9 \rangle}}
\newcommand{\mmev}[9]{\ensuremath{#1 \vdash \langle #2; #3; #4; #5 \rangle \rightarrow^* \langle #6; #7; #8; #9 \rangle}}
\newcommand{\mexec}[9]{\ensuremath{#1 \vdash \langle #2; #3; #4; #5 \rangle \downarrow \langle #6; #7; #8; #9 \rangle}}

\newcommand{\transsm}[3]{\ensuremath{#1 \rhd \langle #2; #3 \rangle}}

\newcommand{\fetch}[3]{\ensuremath{#1 \vdash #2 \uparrow #3}}
\newcommand{\fetchdata}[4]{\ensuremath{#1 \vdash \langle #2, #3 \rangle \uparrow #4}}
\newcommand{\update}[4]{\ensuremath{\mathbf{update}(#1, #2, #3, #4)}}
\newcommand{\allocate}[4]{\ensuremath{\mathbf{allocate}(#1, #2, #3, #4)}}
\newcommand{\fr}[2]{\langle #1; #2 \rangle}
\newcommand{\eqv}[3]{\ensuremath{#1 \downarrow #2 \sim #3}}
\newcommand{\cor}[2]{\ensuremath{#1 \rightsquigarrow #2}}
\newcommand{\vcor}[3]{\ensuremath{#1 \vdash #2 \rightsquigarrow #3}}
\newcommand{\comp}[3]{\ensuremath{#1 \stackrel{#2}{\rightsquigarrow} #3}}
\newcommand{\scomp}{\cor}
% hopefully temporary:
\newcommand{\e}{e} % hoas expressions, previously 'e'
\renewcommand{\c}{c} % canonical forms, previously 'v'
\renewcommand{\b}{b} % de bruijn expressions, previously '\h{\e}'
\renewcommand{\v}{v} % values, previously '\h{v}'
\newcommand{\s}{s}
\renewcommand{\ss}{p} % previously '\s^*'
\newcommand{\w}{w}
\newcommand{\q}{q}
\newcommand{\hq}{\hat{q}}
\renewcommand{\r}{r}
\renewcommand{\k}{k}
\newcommand{\m}{m}
\renewcommand{\h}{h}
\renewcommand{\o}{o}
\renewcommand{\l}{\ell}

\newcommand{\f}{f}
\newcommand{\B}{B}
\renewcommand{\H}{H}
\newcommand{\mfr}[4]{\set{\mathtt{regs}:#1, \mathtt{env}:#2, \mathtt{arg}:#3, \mathtt{ret}:#4}}


\newcommand{\mnil}{[]}
\newcommand{\mcons}{::}
\newcommand{\mnode}{\wedge}

\newcommand{\trasl}[3]{#1 \rhd \tup{#2 ; #3}}
\newcommand{\snum}{\mathtt{num} \;}
\newcommand{\svar}{\mathtt{var} \;}
\newcommand{\slam}{\mathtt{mkclos} \;}
\renewcommand{\sapp}{\mathtt{app}}

\newcommand{\ssnil}{[]}
\renewcommand{\a}{\alpha}
\renewcommand{\b}{\beta}
\renewcommand{\c}{\gamma}





\newcounter{statementcounter}
\newtheorem{lemma}[statementcounter]{Lemma}
\newtheorem{theorem}[statementcounter]{Theorem}

\newenvironment{proof}[1][Proof]{
\paragraph{#1}
}{
\begin{flushright}
$\blacksquare$
\end{flushright}
}

\begin{document}

%\section*{Introduction}
%
%There are several ways of ensuring the correctness of a compiler.
%One way is through extensive testing, though in practice this is never quite sufficient to be rid of all errors [citation?].
%Another way is to prove correctness through some external mechanism.
%Yet another way, which is a variation of this idea, is to develop the compiler in such a way that it is correct by construction.
%
%This last option is the subject of this inquiry.
%Using a dependently typed language it is possible to encode properties about the behaviour of the program in its types --- in particular, given the right types, the mere fact that a program type checks is a witness that it is a correct compiler with respect to the semantics of the source and target languages.
%
%We use the Twelf logic programming language, which is based on the LF logical framework [citation Pfenning].
%Twelf is dependently typed, but it is limited in other respects such as only being able to prove metatheorems of the form $\Pi \cdots \Pi \Sigma \cdots \Sigma$ [what's the proper description?].
%Hence, for a given statement it is not a priori clear whether Twelf is capable of proving (or even stating) it, even if a proof exists on paper.
%On the other hand, Twelf has higher-order abstract syntax offering advantages when dealing with binders.
%
%Our aim therefore is to investigate the feasibility of implementing a verified compiler using Twelf.
%
%\section*{Previous Work}
%
%The main work in this area is the CompCert C verified compiler, a ``high-assurance compiler for almost all of the ISO C90 / ANSI C language, generating efficient code for the PowerPC, ARM and x86 processors'' [cite http://compcert.inria.fr/].
%It targets embedded programming and is written almost entirely in Coq (exceptions being the parser and the assembly code pretty-printer).
%Notably, the compiler implements non-trivial optimisations such as inlining.
%
%The same framework has been used to make a compiler for mini-ML with progress towards verified garbage collection [cite Xavier Leroy].
%
%Another project similarly achieves verified compilation for an ML-like language using Coq [cite Adam Chlipala].
%The focus is on maintainability of the compiler, in particular using parameterised higher-order abstract syntax, while memory management is largely ignored.
%
%[maybe mention PILSNER, a compositionally verified compiler]
%

\section*{Overview}

The translation employs two intermediate languages to more clearly separate the different aspects of the equivalence between the source language and the machine language.

Firstly, named variables are turned into De-Bruijn indices and closures are represented explicitly.
Secondly, the syntax is partially linearised and the semantics are based on an abstract machine.
Finally, the entire program is linearised.

\ensurecommand{\h}{\hat}

\section*{Source Language}
The source language represents the abstract syntax tree of the program text.

\subsection*{Syntax}

Let $n$ denote natural numbers and $x$ variable identifiers. We then define source language expressions $e$ and canonical forms $\h{e}$:
\begin{align*}
  e &\defi \n{n} \alt x \alt \lam{x}{e_1} \alt e_1 \app e_2 \alt \hsuc{e_1} \\ % \alt (\hcase{e_1}{e_2}{e_3}) \\
  \h{e} &\defi \n{n} \alt \lam{x}{e} \quad (\text{with} \; FV(e) \subseteq \set{x}) \\
\end{align*}

\subsection*{Semantics}

The source language has a completely standard substitution-based semantics.

\vspace{0.5cm}

\ensurecommand{\hev}[2]{\ensuremath{#1 \downarrow #2}}
\judgement{\hev{e}{\h{e}}} ($e$ closed)

\begin{prooftree}
  \leftl{\rule{E-Num} :}
  \ax{\hev{\n{n}}{\n{n}}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rule{E-Lam} :}
  \ax{\hev{\lam{x}{e_1}}{\lam{x}{e_1}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\hev{e_1}{\lam{x}{e_0}}}
  \ninf{\hev{e_2}{\h{e}_2}}
  \ninf{\hev{\sub{e_0}{\h{e}_2}{x}}{\h{e}}}
	\leftl{\rule{E-App} :}
  \tinf{\hev{e_1 \app e_2}{\h{e}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\hev{e_1}{\n{n}}}
	\leftl{\rule{E-Suc} :}
  \uinf{\hev{\hsuc{e_1}}{\n{n+1}}}
\end{prooftree}

%% \begin{prooftree}
%%   \ninf{\hev{\e_1}{\n{0}}}
%%   \ninf{\hev{\e_2}{\c_2}}
%% 	\leftl{\rule{E-Case-z} :}
%%   \binf{\hev{\hcase{\e_1}{\e_2}{\e_3}}{\c_2}}
%% \end{prooftree}

%% \begin{prooftree}
%%   \ninf{\hev{\e_1}{\n{n}}}
%%   \ninf{\hev{\sub{\e_3}{\n{n-1}}{x}}{\c_3}}
%% 	\leftl{\rule{E-Case-s} :}
%% 	\rightl{$(n > 0)$}
%%   \binf{\hev{\hcase{\e_1}{\e_2}{\e_3}}{\c_3}}
%% \end{prooftree}

\section*{De Bruijn Language}
The De-Bruijn language differs from the source language in two important ways: variables are represented by De-Bruijn indices and closures are managed explicitly instead of substituting arguments.

\ensurecommand{\blam}{\lam{}}

\subsection*{Syntax}

We define variable indices $i$ and De Bruijn expressions $b$ as follows:
\begin{align*}
	i &\defi \z \alt \suc i \\
	\b &\defi \n{n} \alt i \alt \lam{b_1} \alt b_1 \app b_2 \alt \bsuc{b_1} \\ % \alt \bcase{\b_1}{\b_2}{\b_3}
\end{align*}

\subsection*{Semantics}

The semantics of the De Bruijn language is environment-based.
We define De-Bruijn values $\h{b}$ as follows, and environments $\a$ are then ordered lists of values.
\begin{align*}
  \h{b} &\defi \n{n} \alt \cl{\sg}{\b} \alt x \\
  \a &\defi \nil \alt \a, \h{b} \\
\end{align*}

We introduce an auxiliary judgement for variable lookup.

\vspace{0.5cm}

\ensurecommand{\hlook}[3]{\ensuremath{#1 \vdash #2 \uparrow #3}}
\judgement{\hlook{\a}{i}{\h{b}}}

\begin{prooftree}
  \leftl{\rule{Bv-Here} :}
  \ax{\hlook{\a, \h{b}}{\z}{\h{b}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\hlook{\sg}{i}{\h{b}}}
  \leftl{\rule{Bv-There} :}
  \uinf{\hlook{\sg, \h{b}'}{\suc i}{\h{b}}}
\end{prooftree}

\ensurecommand{\bev}[3]{\ensuremath{#1 \vdash #2 \downarrow #3}}
\judgement{\bev{\a}{b}{\h{b}}}

\begin{prooftree}
  \leftl{\rule{B-Num} :}
  \ax{\bev{\a}{\n{n}}{\n{n}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\hlook{\a}{i}{\h{b}}}
  \leftl{\rule{B-Var} :}
  \uinf{\bev{\a}{i}{\h{b}}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rule{B-Lam :}}
  \ax{\bev{\a}{\blam{b_1}}{\cl{\a}{b_1}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\bev{\a}{b_1}{\cl{\a'}{b_0}}}
  \ninf{\bev{\a}{b_2}{\h{b}_2}}
  \ninf{\bev{\a' :: \h{b}_2}{b_0}{\h{b}}}
	\leftl{\rule{B-App} :}
  \tinf{\bev{\a}{b_1 \app b_2}{\h{b}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\bev{\a}{b_1}{\n{n}}}
	\leftl{\rule{B-Suc} :}
  \uinf{\bev{\a}{\bsuc{b_1}}{{\n{n+1}}}}
\end{prooftree}

%% \begin{prooftree}
%%   \ninf{\hev{\a}{\b_1}{\n{0}}}
%%   \ninf{\hev{\a}{\b_2}{\v_2}}
%% 	\leftl{\rule{B-Case-z} :}
%%   \binf{\hev{\a}{\bcase{\b_1}{\b_2}{\b_3}}{\v_2}}
%% \end{prooftree}

%% \begin{prooftree}
%%   \ninf{\hev{\a}{\b_1}{\n{n}}}
%%   \ninf{\hev{\a, \n{n-1}}{b_3}{\v_3}}
%% 	\leftl{\rule{B-Case-s} :}
%% 	\rightl{$(n > 0)$}
%%   \binf{\hev{\a}{\bcase{\b_1}{\b_2}{\b_3}}{\v_3}}
%% \end{prooftree}


\subsection*{Translation}

We define the type of correspondence contexts.

\begin{align*}
  \Theta &\defi \nil \alt \Theta :: \cor{\v}{x}
\end{align*}

\ensurecommand{\trahb}[4]{\ensuremath{#2 \vdash #3 \rhd #4}}
%\ensurecommand{\cor}[2]{\ensuremath{#1 \rightsquiqarrow #2}}
\ensurecommand{\corhb}[3]{\ensuremath{#2 \rightsquigarrow #3}}

\judgement{\trahb{\Theta}{\a}{b}{e}}

% explain why it is going in the 'wrong' direction

\begin{prooftree}
  \leftl{\rule{T-Num} :}
  \ax{\trahb{\Theta}{\a}{\n{n}}{\n{n}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\hevv{\a}{i}{\h{b}}}
  \ninf{\corhb{\Theta}{\h{b}}{e}}
  \leftl{\rule{T-Var} :}
  \binf{\trahb{\Theta}{\a}{i}{e}}
\end{prooftree}

[In the following rule, should $\h{b}$ really be existentially quantified? Would we not want to require the premise to hold for all possible choices for $\h{b}$?]
\begin{prooftree}
	\ninf{\trahb{\Theta}{\a :: x}{b_1}{e_1}}
  \leftl{\rule{T-Lam} :}
  \uinf{\trahb{\Theta}{\a}{\blam{b_1}}{\lam{x}{e_1}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\Theta}{\a}{b_1}{e_1}}
  \ninf{\trahb{\Theta}{\a}{b_2}{e_2}}
	\leftl{\rule{T-App} :}
  \binf{\trahb{\Theta}{\a}{b_1 \app b_2}{e_1 \app e_2}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\Theta}{\a}{b_1}{e_1}}
	\leftl{\rule{T-Suc} :}
  \uinf{\trahb{\Theta}{\a}{\bsuc{b_1}}{\hsuc{e_1}}}
\end{prooftree}

%% \begin{prooftree}
%% 	\ninf{\trahb{\Theta}{\a}{b_1}{e_1}}
%% 	\ninf{\trahb{\Theta}{\a}{b_2}{e_2}}
%% 	\ninf{\trahb{\Theta, \cor{\h{b}}{x}}{\a, \h{b}}{b_3}{e_3}}
%%   \leftl{\rule{T-Case} :}
%%   \rightl{$(\forall \h{b}' . \; (\cor{\h{b}'}{x}) \notin \Theta)$}
%%   \tinf{\trahb{\Theta}{\a}{\bcase{b_1}{b_2}{b_3}}{\hcase{e_1}{e_2}{e_3}}}
%% \end{prooftree}

We define a correspondence between values and expressions in canonical form:

\vspace{0.5cm}

\judgement{\corhb{\Theta}{\h{b}}{e}}

\begin{prooftree}
  \leftl{\rule{C-Var} :}
  \ax{\vcor{\Theta}{x}{x}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rule{C-Num} :}
  \ax{\corhb{\Theta}{\n{n}}{\n{n}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\Theta}{\a}{\blam{b}}{\lam{x}{e}}}
  \leftl{\rule{C-Fun} :}
  \uinf{\corhb{\Theta}{\cl{\a}{b}}{\lam{x}{e}}}
\end{prooftree}


\subsection*{Equivalence}
\begin{lemma}[Substitution]
\label{lem:substitution}
Given a variable $x$, if \trahb{\Theta}{\a}{b}{e} and \corhb{\Theta}{\h{b}'}{\h{e}'} then \trahb{\Theta}{\a[\h{b}'/x]}{b}{e[\h{e}'/x]}.
\end{lemma}


\begin{lemma}[Soundness]
\label{lem:soundness-hb}
If \trahb{\Theta}{\a}{b}{e} (by $\T$) and \bev{\a}{b}{\h{b}} (by $\B$), then there exists $\h{e}$ such that \hev{e}{\h{e}} (by some $\E$) and \corhb{\Theta}{\h{b}}{\h{e}} (by some $\C$).
\end{lemma}

\begin{proof}

By induction on $\B$. We proceed by case analysis on $\T$.

\paragraph{Case \textnormal{\rule{T-Lam}}}
$\T$ has the form
\begin{prooftree}
	\prem{\T_1}{\trahb{\Theta}{\a :: x}{b_1}{e_1}}
  \uinf{\trahb{\Theta}{\a}{\blam{b_1}}{\lam{x}{e_1}}}
\end{prooftree}
Hence, $\B$ must be
\begin{prooftree}
  \ax{\bev{\a}{\blam{b_1}}{\cl{\a}{b_1}}}
\end{prooftree}
Using \rule{E-Lam} we get \hev{\lam{x}{e_1}}{\lam{x}{e_1}} and construct the required correspondence as follows:
\begin{prooftree}
  \prem{\T}{\trahb{\Theta}{\a}{\blam{b_1}}{\lam{x}{e_1}}}
  \uinf{\corhb{\Theta}{\cl{\a}{b_1}}{\lam{x}{e_1}}}
\end{prooftree}


\paragraph{Case \textnormal{\rule{T-App}}}
$\T$ has the form
\begin{prooftree}
  \prem{\T_1}{\trahb{\Theta}{\a}{b_1}{e_1}}
  \prem{\T_2}{\trahb{\Theta}{\a}{b_2}{e_2}}
  \binf{\trahb{\Theta}{\a}{b_1 \app b_2}{e_1 \app e_2}}
\end{prooftree}
Hence, $\B$ must be
\begin{prooftree}
  \prem{\B_1}{\bev{\a}{b_1}{\cl{\a'}{b_0}}}
  \prem{\B_2}{\bev{\a}{b_2}{\h{b}_2}}
  \prem{\B_3}{\bev{\a' :: \h{b}_2}{b_0}{\h{b}}}
  \tinf{\bev{\a}{b_1 \app b_2}{\h{b}}}
\end{prooftree}

By IH on $\B_1$ with $\T_1$ we get \hev{e_1}{\h{e}_1} by some $\E_1$ and \corhb{\Theta}{\cl{\a'}{b_0}}{\h{e}_1} by some $\C_1$ which must have the shape
\begin{prooftree}
	\prem{T_3}{\trahb{\Theta}{\a :: x}{b_0}{e_0}}
  \uinf{\trahb{\Theta}{\a}{\blam{b_0}}{\lam{x}{e_0}}}
  \uinf{\corhb{\Theta}{\cl{\a'}{b_0}}{\lam{x}{e_0}}}
\end{prooftree}
so $\h{e}_1 = \lam{x}{e_0}$.

By IH on $\B_2$ with $\T_2$ we get \hev{e_2}{\h{e}_2} by some $\E_2$ and \corhb{\Theta}{\h{b}_2}{\h{e}_2} by some $\C_2$.
Using Lemma~\ref{lem:substitution} on $\T_3$ with $\C_2$ we get \trahb{\Theta}{\a :: \h{b}_2}{b_0}{e_0[\h{e_2}/x]} (by some $\T_3'$).
By IH on $\B_3$ with $\T_3'$ we get \hev{e_0[\h{e}_2/x]}{\h{e}} by some $\E_3$ and $\corhb{\Theta}{\h{b}}{\h{e}}$ by some $\C_3$.
The case is finished using \rule{E-App} with $\E_1$, $\E_2$ and $\E_3$; the required correspondence is provided by $\C_3$.

\end{proof}

\begin{lemma}[Completeness]
\label{lem:completeness-hb}
If \trahb{\Theta}{\a}{b}{e} (by $\T$) and \hev{e}{\h{e}} (by $\E$), then there exists $\h{b}$ such that \bev{\a}{b}{\h{b}} (by some $\B$) and \corhb{\Theta}{\h{b}}{\h{e}} (by some $\C$).
\end{lemma}


%% \subsection*{Equivalence}

%% \begin{theorem} [Equivalence source-Bruijn]
%% \label{thm:equiv-hb} If \tra{\nil}{\b}{\e}, then \ev{\e}{\n{n}} if and only if \hev{\nil}{\b}{\n{n}}.
%% \end{theorem}

%% To prove this, we first generalise to the following lemmas.

%% \ldots

%% \begin{lemma}[Evaluation of Values]
%% \label{lem:value-eval}
%% For all $\c$, \ev{\c}{\c}.
%% \end{lemma}

%% \begin{lemma}[Determinism]
%% \label{lem:determ}
%% If \ev{\e}{\c} and \ev{\e}{c'}, then $\c = \c'$.
%% \end{lemma}

%% \begin{lemma}
%% \label{lem:left-to-right-var}
%% If \trav{\De}{x}{i} (by $\Tv$) and \comp{\sg}{\De}{\phi} (by $\D$), then there exists $\v$ such that \hevv{\sg}{i}{\v} (by some $\Bv$), $x \in \dom(\phi)$ and \cor{\v}{\phi(x)} (by some $\C$).
%% \end{lemma}

%% \begin{proof}
%% By induction on $\Tv$.

%% \paragraph{Case \textnormal{\rule{Tv-Here}}}

%% \begin{prooftree}
%%   \leftl{$\Tv =$}
%%   \ax{\trav{\De', x}{x}{\z}}
%% \end{prooftree}
%% So $\De = \De', x$ and $i = \z$.
%% Then $\D$ must have the form
%% \begin{prooftree}
%%   \prem{\D_1}{\comp{\sg'}{\De'}{\phi'}}
%%   \prem{\C'}{\cor{\v}{\c}}
%%   \binf{\comp{\sg', \v}{\De', x}{\phi'[x \mapsto \c]}}
%% \end{prooftree}
%% So $\sg = \sg', \v$ and $\phi = \phi'[x \mapsto \c]$.
%% We now get the required derivation $\Bv$ of $\hevv{\sg', \v}{\z}{\v}$ directly by rule \rule{Bv-Here}.
%% And since $\phi(x) = \phi'[x \mapsto \c](x) = \c$, we can take $\C = \C'$.

%% \paragraph{Case \textnormal{\rule{Tv-There}}}

%% \begin{prooftree}
%%   \prem{\Tv_1}{\trav{\De}{x}{i'}}
%%   \leftl{$\Tv =$}
%% 	\rightl{$(x \neq y)$}
%%   \uinf{\trav{\De', y}{x}{\suc i'}}
%% \end{prooftree}
%% So $\De = \De', y$ and $i = \suc i'$.
%% Then $\D$ must have the form
%% \begin{prooftree}
%%   \prem{\D_1}{\comp{\sg'}{\De'}{\phi'}}
%%   \prem{\C'}{\cor{\v'}{\c'}}
%%   \binf{\comp{\sg', \v'}{\De', y}{\phi'[y \mapsto \c']}}
%% \end{prooftree}
%% So $\sg = \sg', \v'$ and $\phi = \phi'[y \mapsto \c']$.

%% Now by IH on $\Tv_1$ with $\D_1$, we get derivations $\Bv_1$ of $\hevv{\sg'}{i'}{\v}$ and $\C_1$ of $\cor{\v}{\phi'(x)}$.
%% We construct the required derivation $\Bv$ as follows:
%% \begin{prooftree}
%%   \prem{\Bv_1}{\hevv{\sg'}{i'}{\v}}
%%   \uinf{\hevv{\sg', \v'}{\suc i'}{\v}}
%% \end{prooftree}
%% And since $\phi(x) = \phi'[y \mapsto \c'](x) = \phi'(x)$ (because $x \neq y$), we can take $\C = \C_1$.

%% \end{proof}

%% \begin{lemma}
%% \label{lem:completeness-hb}
%% If \tra{\De}{\e}{\b} (by $\T$), \ev{\subs{\e}{\phi}}{\c} (by $\E$) and \comp{\sg}{\De}{\phi} (by $\D$), then there exists $\v$ such that \hev{\sg}{\b}{\v} (by some $\B$) and \cor{\v}{\c} (by some $\C$).
%% \end{lemma}

%% \begin{proof}
%% By induction on $\E$. We proceed by case analysis on $\e$.

%% \paragraph{Case $\e = \n{n}$}

%% $\T$ must end in \rule{T-Num} and so $\b = \n{n}$.
%% We have $\subs{\e}{\phi} = \n{n}$, so $\E$ must end in \rule{E-Num} and $v = \n{n}$.
%% Taking $\v = \n{n}$, by rule \rule{B-Num} we get a derivation $\B$ of $\hev{\sg}{\n{n}}{\n{n}}$ as required.
%% And $\cor{\n{n}}{\n{n}}$ by rule \rule{C-Num}.

%% \paragraph{Case $\e = x$}

%% $\T$ must have the form
%% \begin{prooftree}
%%   \prem{\Tv}{\trav{\De}{x}{i}}
%%   \uinf{\tra{\De}{x}{i}}
%% \end{prooftree}
%% So $\b = i$.
%% We have $\subs{\e}{\phi} = \phi(x)$ and $\E$ shows \ev{\phi(x)}{\c}.
%% By Lemma~\ref{lem:value-eval} and Lemma~\ref{lem:determ} combined we get $\c = \phi(x)$.
%% Now by Lemma~\ref{lem:left-to-right-var} on $\Tv$ and $\D$, we get derivations $\Bv$ of \hevv{\sg}{i}{\v'} and $\C'$ of $\cor{\v'}{\phi(x)}$ (for some $\v'$).

%% Taking $\v = \v'$, we construct the required $\B$ as follows and take $\C = \C'$:
%% \begin{prooftree}
%%   \prem{\Bv}{\hevv{\sg}{i}{\v'}}
%%   \uinf{\hev{\sg}{i}{\v'}}
%% \end{prooftree}

%% \paragraph{Case $\e = \lam{x}{\e_1}$}

%% $\T$ must have the form
%% \begin{prooftree}
%% 	\prem{\T_1}{\tra{\De, x}{\e_1}{\b_1}}
%%   \uinf{\tra{\De}{\lam{x}{\e_1}}{\lam{}{\b_1}}}
%% \end{prooftree}
%% So $\b = \lam{}{\b_1}$. We have $\subs{\e}{\phi} = \subs{(\lam{x}{\e_1})}{\phi} = \lam{x}{\subs{\e_1}{\phi \wo x}}$, so $\E$ must end in \rule{E-Lam} and $v = \lam{x}{\subs{\e_1}{\phi \wo x}}$.
%% Taking $\v = \cl{\sg}{\b_1}$, we get the required $\B$ showing $\hev{\sg}{\lam{}{\b_1}}{\cl{\sg}{\b_1}}$ by rule \rule{B-Lam}.
%% And we construct the required derivation $\C$ as follows:
%% \begin{prooftree}
%%   \prem{\D}{\comp{\sg}{\De}{\phi}}
%%   \prem{\T_1}{\tra{\De, x}{\e_1}{\b_1}}
%%   \binf{\cor{\cl{\sg}{\b_1}}{\lam{x}{\subs{\e_1}{\phi \wo x}}}}
%% \end{prooftree}

%% \paragraph{Case $\e = \e_1 \app \e_2$}

%% $\T$ must have the form
%% \begin{prooftree}
%%   \prem{\T_1}{\tra{\De}{\e_1}{\b_1}}
%%   \prem{\T_2}{\tra{\De}{\e_2}{\b_2}}
%%   \binf{\tra{\De}{\e_1 \app \e_2}{\b_1 \app \b_2}}
%% \end{prooftree}
%% So $\b = \b_1 \app \b_2$.

%% We have $\subs{\e}{\phi} = \subs{\e_1}{\phi} \app \subs{\e_2}{\phi}$, so $\E$ must end in \rule{E-App} and have the form
%% \begin{prooftree}
%%   \prem{\E_1}{\ev{\subs{\e_1}{\phi}}{\lam{x}{\e_0}}}
%%   \prem{\E_2}{\ev{\subs{\e_2}{\phi}}{\c_2}}
%%   \prem{\E_3}{\ev{\sub{\e_0}{\c_2}{x}}{\c}}
%%   \tinf{\ev{\subs{\e_1}{\phi} \app \subs{\e_2}{\phi}}{\c}}
%% \end{prooftree}

%% By IH on $\E_1$ with $\T_1$ and $\D$, we get derivations $\B_1$ of \hev{\sg}{\b_1}{\v_1} and $\C_1$ of \cor{\v_1}{\lam{x}{\e_0}} (for some $\v_1$).
%% $\C_1$ must have the form
%% \begin{prooftree}
%%   \prem{\D_1'}{\comp{\sg'}{\De'}{\phi'}}
%%   \prem{\T_1'}{\tra{\De', x}{\e_0'}{\b_0}}
%%   \binf{\cor{\cl{\sg'}{\b_0}}{\lam{x}{\subs{\e_0'}{\phi' \wo x}}}}
%% \end{prooftree}
%% So $\e_0 = \subs{\e_0'}{\phi' \wo x}$ and $\v_1 = \cl{\sg'}{\b_0}$.

%% By IH on $\E_2$ with $\T_2$ and $\D$, we get derivations $\B_2$ of \hev{\sg}{\b_2}{\v_2} and $\C_2$ of \cor{\v_2}{\c_2}.
%% We have $\sub{\subs{\e_0'}{\phi' \wo x}}{\c_2}{x} = \subs{\e_0'}{\phi'[x \mapsto \c_2]}$.
%% In particular, $\E_3$ shows \ev{\subs{\e_0'}{\phi'[x \mapsto \c_2]}}{\c}.
%% We construct the following derivation $\D'$ of $\comp{\sg', \v_2}{\De', x}{\phi'[x \mapsto \c_2]}$:
%% \begin{prooftree}
%%   \prem{\D_1'}{\comp{\sg'}{\De'}{\phi'}}
%%   \prem{\C_2}{\cor{\v_2}{\c_2}}
%%   \binf{\comp{\sg', \v_2}{\De', x}{\phi'[x \mapsto \c_2]}}
%% \end{prooftree}

%% Then by IH on $\E_3$ with $\T_1'$ and $\D'$, we get a derivation $\B_3$ of \hev{\sg', \v_2}{\b_0}{\v} along with the required $\C$ showing \cor{\v}{\c}.
%% And finally we construct the required derivation $\B$ as follows:
%% \begin{prooftree}
%%   \prem{\B_1}{\hev{\sg}{\b_1}{\cl{\sg'}{\b_0}}}
%%   \prem{\B_2}{\hev{\sg}{\b_2}{\v_2}}
%%   \prem{\B_3}{\hev{\sg', \v_2}{\b_0}{\v}}
%%   \tinf{\hev{\sg}{\b_1 \app \b_2}{\v}}
%% \end{prooftree}

%% \end{proof}

%% \begin{lemma}
%% \label{lem:right-to-left-var}
%% If \trav{\De}{x}{i} (by $\Tv$), \hevv{\sg}{i}{\v} (by $\Bv$) and \comp{\sg}{\De}{\phi} (by $\D$), then $x \in \dom(\phi)$ and \cor{\v}{\phi(x)} (by some $\C$).
%% \end{lemma}

%% \begin{proof}
%% By induction on $\Tv$.

%% \paragraph{Case \textnormal{\rule{Tv-Here}}}

%% \begin{prooftree}
%%   \leftl{$\Tv =$}
%%   \ax{\trav{\De', x}{x}{\z}}
%% \end{prooftree}
%% So $\De = \De', x$ and $i = \z$.
%% Thus, $\Bv$ has the form
%% \begin{prooftree}
%%   \ax{\hevv{\sg', \v}{\z}{\v}}
%% \end{prooftree}
%% Hence $\sg = \sg', v$.
%% Now, given the shape of $\sg$ and $\De$, $\D$ must have the form
%% \begin{prooftree}
%%   \prem{\D_1}{\comp{\sg'}{\De'}{\phi'}}
%%   \prem{\C'}{\cor{\v}{\c}}
%%   \binf{\comp{\sg', \v}{\De', x}{\phi'[x \mapsto \c]}}
%% \end{prooftree}
%% So $\phi = \phi'[x \mapsto \c]$ and consequently $\phi(x) = c$.
%% In particular, $x \in \dom(\phi)$ and \cor{\v}{c} (taking $\C = \C'$) as required.

%% \paragraph{Case \textnormal{\rule{Tv-There}}}

%% \begin{prooftree}
%%   \prem{\Tv_1}{\trav{\De}{x}{i'}}
%%   \leftl{$\Tv =$}
%% 	\rightl{$(x \neq y)$}
%%   \uinf{\trav{\De', y}{x}{\suc i'}}
%% \end{prooftree}
%% So $\De = \De', y$ and $i = \suc i'$.
%% Thus, $\Bv$ has the form
%% \begin{prooftree}
%%   \prem{\Bv_1}{\hevv{\sg'}{i}{\v}}
%%   \uinf{\hevv{\sg', \v'}{\suc i}{\v}}
%% \end{prooftree}
%% Hence $\sg = \sg', v'$.

%% Now, given the shape of $\sg$ and $\De$, $\D$ must have the form
%% \begin{prooftree}
%%   \prem{\D_1}{\comp{\sg'}{\De'}{\phi'}}
%%   \prem{\C'}{\cor{\v'}{\c'}}
%%   \binf{\comp{\sg', \v'}{\De', y}{\phi'[y \mapsto \c']}}
%% \end{prooftree}
%% So $\phi = \phi'[y \mapsto \c']$.

%% Now by IH on $\Tv_1$ with $\Bv_1$ and $\D_1$, we get $x \in \dom(\phi')$ and a derivation $\C_1$ of $\cor{\v}{\phi'(x)}$.
%% Since $x \neq y$ we have $\phi(x) = \phi'(x)$.
%% Thus, $x \in \dom(\phi')$ and we can take $\C = \C_1$ to complete the proof.

%% \end{proof}

%% \begin{lemma}
%% \label{lem:soundness-hb}
%% If \tra{\De}{\e}{\b} (by $\T$), \hev{\sg}{\b}{\v} (by $\B$) and \comp{\sg}{\De}{\phi} (by $\D$), then there exists $\c$ such that \ev{\subs{\e}{\phi}}{\c} (by some $\E$) and \cor{\v}{\c} (by some $\C$).
%% \end{lemma}

%% \begin{proof}
%% By induction on $\B$.

%% \paragraph{Case \textnormal{\rule{B-Num}}}

%% \begin{prooftree}
%%   \leftl{$\B =$}
%%   \ax{\hev{\sg}{\n{n}}{\n{n}}}
%% \end{prooftree}
%% So $\b = \v = \n{n}$.

%% $\T$ must end in \rule{T-Num} and so $\e = \n{n}$.
%% Since $\subs{\e}{\phi} = \n{n}$, we can take $\c = \n{n}$ and get the required derivation $\E$ of $\ev{\n{n}}{\n{n}}$ by rule \rule{E-Num}.
%% And $\cor{\n{n}}{\n{n}}$ by rule \rule{C-Num}.

%% \paragraph{Case \textnormal{\rule{B-Var}}}

%% \begin{prooftree}
%%   \prem{\Bv}{\hevv{\sg}{i}{\v}}
%%   \leftl{$\B =$}
%%   \uinf{\hev{\sg}{i}{\v}}
%% \end{prooftree}
%% So $\b = i$, and $\T$ must have the form
%% \begin{prooftree}
%%   \prem{\Tv}{\trav{\De}{x}{i}}
%%   \uinf{\tra{\De}{x}{i}}
%% \end{prooftree}
%% So $\e = x$.
%% By Lemma~\ref{lem:right-to-left-var} on $\Tv$, $\Bv$ and $\D$, we get $x \in \dom(\phi)$ and a derivation $\C'$ of $\cor{\v}{\phi(x)}$.
%% We then have $\subs{\e}{\phi} = \phi(x)$, which by definition is a canonical form.
%% Taking $\c = \phi(x)$, we get a suitable derivation $\E$ of $\ev{\phi(x)}{\phi(x)}$ by Lemma~\ref{lem:value-eval}.
%% And we can take $\C = \C'$.

%% \paragraph{Case \textnormal{\rule{B-Lam}}}

%% \begin{prooftree}
%%   \leftl{$\B =$}
%%   \ax{\hev{\sg}{\lam{}{\b_1}}{\cl{\sg}{\b_1}}}
%% \end{prooftree}
%% So $\b = \lam{}{\b_1}$ and $\v = \cl{\sg}{\b_1}$.
%% $\T$ must have the form
%% \begin{prooftree}
%% 	\prem{\T_1}{\tra{\De, x}{\e_1}{\b_1}}
%%   \uinf{\tra{\De}{\lam{x}{\e_1}}{\lam{}{\b_1}}}
%% \end{prooftree}
%% So $\e = \lam{x}{\e_1}$.
%% We have $\subs{\e}{\phi} = \subs{(\lam{x}{\e_1})}{\phi} = \lam{x}{\subs{\e_1}{\phi \wo x}}$, and taking $\c = \lam{x}{\subs{\e_1}{\phi \wo x}}$ we get the required $\E$ showing $\ev{\lam{x}{\subs{\e_1}{\phi \wo x}}}{\lam{x}{\subs{\e_1}{\phi \wo x}}}$ by rule \rule{E-Lam}.
%% We then construct the required $\C$ using rule \rule{C-Fun} as follows:
%% \begin{prooftree}
%%   \prem{\D}{\comp{\sg}{\De}{\phi}}
%%   \prem{\T_1}{\tra{\De, x}{\e_1}{\b_1}}
%%   \binf{\cor{\cl{\sg}{\b_1}}{\lam{x}{\subs{\e_1}{\phi \wo x}}}}
%% \end{prooftree}

%% \paragraph{Case \textnormal{\rule{B-App}}}

%% \begin{prooftree}
%%   \prem{\B_1}{\hev{\sg}{\b_1}{\cl{\sg'}{\b_0}}}
%%   \prem{\B_2}{\hev{\sg}{\b_2}{\v_2}}
%%   \prem{\B_3}{\hev{\sg', \v_2}{\b_0}{\v}}
%%   \leftl{$\B =$}
%%   \tinf{\hev{\sg}{\b_1 \app \b_2}{\v}}
%% \end{prooftree}
%% So $\b = \b_1 \app \b_2$.
%% $\T$ must have the form
%% \begin{prooftree}
%%   \prem{\T_1}{\tra{\De}{\e_1}{\b_1}}
%%   \prem{\T_2}{\tra{\De}{\e_2}{\b_2}}
%%   \binf{\tra{\De}{\e_1 \app \e_2}{\b_1 \app \b_2}}
%% \end{prooftree}
%% So $\e = \e_1 \app \e_2$.

%% By IH on $\B_1$ with $\T_1$ and $\D$, we get derivations $\E_1$ of \ev{\subs{\e_1}{\phi}}{\c_1} and $\C_1$ of \cor{\cl{\sg'}{\b_0}}{\c_1} (for some $\c_1$).
%% $\C_1$ must have the form
%% \begin{prooftree}
%%   \prem{\D_1'}{\comp{\sg'}{\De'}{\phi'}}
%%   \prem{\T_1'}{\tra{\De', x}{\e_0'}{\b_0}}
%%   \binf{\cor{\cl{\sg'}{\b_0}}{\lam{x}{\subs{\e_0'}{\phi' \wo x}}}}
%% \end{prooftree}
%% So $\c_1 = \lam{x}{\subs{\e_0'}{\phi' \wo x}}$.

%% By IH on $\B_2$ with $\T_2$ and $\D$, we get derivations $\E_2$ of \ev{\subs{\e_2}{\phi}}{\c_2} and $\C_2$ of \cor{\v_2}{\c_2}.
%% We construct the following derivation $\D'$ of $\comp{\sg', \v_2}{\De', x}{\phi'[x \mapsto \c_2]}$:
%% \begin{prooftree}
%%   \prem{\D_1'}{\comp{\sg'}{\De'}{\phi'}}
%%   \prem{\C_2}{\cor{\v_2}{\c_2}}
%%   \binf{\comp{\sg', \v_2}{\De', x}{\phi'[x \mapsto \c_2]}}
%% \end{prooftree}

%% Then by IH on $\B_3$ with $\T_1'$ and $\D'$, we get a derivation $\E_3$ of \mbox{\ev{\subs{\e_0'}{\phi'[x \mapsto \c_2]}}{\c}} along with the required $\C$ showing \cor{\v}{\c}.
%% We have $\subs{\e_0'}{\phi'[x \mapsto \c_2]} = \sub{\subs{\e_0'}{\phi' \wo x}}{\c_2}{x}$, in particular $\E_3$ shows \ev{\sub{\subs{\e_0'}{\phi' \wo x}}{\c_2}{x}}{\c}.
%% And finally, noting $\subs{\e}{\phi} = \subs{\e_1}{\phi} \app \subs{\e_2}{\phi}$, we construct the required derivation $\E$ as follows:
%% \begin{prooftree}
%%   \prem{\E_1}{\ev{\subs{\e_1}{\phi}}{\lam{x}{\subs{\e_0'}{\phi' \wo x}}}}
%%   \prem{\E_2}{\ev{\subs{\e_2}{\phi}}{\c_2}}
%%   \prem{\E_3}{\ev{\sub{\subs{\e_0'}{\phi' \wo x}}{\c_2}{x}}{\c}}
%%   \tinf{\ev{\subs{\e_1}{\phi} \app \subs{\e_2}{\phi}}{\c}}
%% \end{prooftree}

%% \end{proof}

%% We can now establish the main theorem.

%% \begin{proof}[Proof of Theorem~\ref{thm:equiv-hb}]
%% Supposing \tra{\nil}{\e}{\b} (by $\T$), we show the bi-implication.
%% For the left-to-right direction, assume \ev{\e}{\n{n}} (by $\E$) and note $\e = \subs{\e}{\nil}$.
%% Rule \rule{D-Nil} provides $\D$ showing the compatibility of empty contexts.
%% Then use Lemma~\ref{lem:completeness-hb} on $\T$, $\E$ and $\D$ to get \hev{\nil}{\b}{\v} for some $\v$ satisfying \cor{\v}{\n{n}}.
%% But since numbers correspond only to themselves, we must have $\v = \n{n}$ as required.

%% The other direction is analogous, using Lemma~\ref{lem:soundness-hb} instead.
%% \end{proof}

\renewcommand{\nil}{[]}%
\newcommand{\cons}{::}

\newcommand{\seq}{\mathbin{;}}

\renewcommand{\cl}[2]{\{ #1 , #2 \}}%

\renewcommand{\tup}[1]{\langle #1 \rangle}%

\renewcommand{\h}{\hat}%




\section*{Stack Language}

\renewcommand{\snum}[1]{\mathtt{num} \; #1}%
\renewcommand{\svar}[1]{\mathtt{var} \; #1}%
\renewcommand{\slam}[1]{\mathtt{mkclos} \; #1}%
\renewcommand{\sapp}{\mathtt{app}}%
\newcommand{\ssuc}{\mathtt{suc}}


\renewcommand{\b}{\beta}
\newcommand{\G}{\Gamma}
\newcommand{\Ph}{\Phi}
\newcommand{\Ps}{\Psi}

\newcommand{\hs}{\hat{s}}


\renewcommand{\sev}[2]{\ensuremath{#1 \downarrow #2}}%
\newcommand{\sstep}[4]{\ensuremath{\tup{#1, #2} \rightarrow \tup{#3, #4}}}
\newcommand{\ssteps}[4]{\ensuremath{\tup{#1, #2} \rightarrow^* \tup{#3, #4}}}
\renewcommand{\sevv}[3]{\ensuremath{#1 \vdash #2 \uparrow #3}}%


We now develop the next translation target, a stack-based language.
% some text about its purpose, major changes, etc.

\subsection*{Syntax}

We define stack-machine instructions $s$ and programs $p$:
\begin{align*}
  s &\defi \snum{n} \alt \svar{i} \alt \slam{p} \alt \sapp \alt \ssuc \\
  p &\defi \nil \alt s \seq p
\end{align*}
% (Note that $i$ was defined previously.)

\subsection*{Semantics}
% The semantics of the stack language is given as follows:

We define values $\h{s}$, environments $\b$, control stacks $\G$, and value stacks $\Ph$:
\begin{align*}
  \hs &\defi \n{n} \alt \cl{\b}{p} \\
  \b &\defi \nil \alt \b \cons \hs \\
  \G &\defi \nil \alt \G \cons \cl{\b}{p} \\
  \Ph &\defi \nil \alt \Ph \cons \hs \\
\end{align*}

And the semantics judgements:
\vspace{0.5cm}

\judgement{\sev{p}{\hs}}

\begin{prooftree}
  \ninf{\sstep{[\cl{\nil}{p}]}{\nil}{\nil}{[\hs]}}
  \uinf{\sev{p}{\hs}}
\end{prooftree}

\judgement{\sevv{\b}{i}{\hs}}

\begin{prooftree}
  \leftl{\rule{Sv-Here} :}
  \ax{\sevv{\b \cons \hs}{\z}{\hs}}
\end{prooftree}

\begin{prooftree}
  \ninf{\sevv{\b}{i}{\hs}}
  \leftl{\rule{Sv-There} :}
  \uinf{\sevv{\b \cons \hs'}{\suc i}{\hs}}
\end{prooftree}

\judgement{\sstep{\G}{\Ph}{\G'}{\Ph'}}

\begin{prooftree}
  \leftl{\rule{S-Num} :}
  \ax{\sstep{\G \cons \cl{\b}{\snum{n} \seq p}}{\Ph}{\G \cons \cl{\b}{p}}{\Ph \cons \n{n}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\sevv{\b}{i}{\hs}}
  \leftl{\rule{S-Var} :}
  \uinf{\sstep{\G \cons \cl{\b}{\svar{i} \seq p}}{\Ph}{\G \cons \cl{\b}{p}}{\Ph \cons \hs}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rule{S-Lam} :}
  \ax{\sstep{\G \cons \cl{\b}{\slam{p_1} \seq p}}{\Ph}{\G \cons \cl{\b}{p}}{\Ph \cons \cl{\b}{p_1}}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rule{S-App} :}
  \ax{\sstep{\G \cons \cl{\b}{\sapp \seq p}}{\Ph \cons \cl{\b'}{p_1} \cons \hs_2}{\G \cons \cl{\b}{p} \cons \cl{\b' \cons \hs_2}{p_1}}{\Ph}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rule{S-Suc} :}
  \ax{\sstep{\G \cons \cl{\b}{\ssuc \seq p}}{\Ph \cons \n{n}}{\G \cons \cl{\b}{p}}{\Ph \cons \n{n + 1}}}
\end{prooftree}

%\begin{prooftree}
  %\leftl{\rule{S-Case-z} :}
  %\ax{\sev{\Xi, \fr{\tau}{\scase{\ss_1}{\ss_2}, \ss}}{\Psi, \n{\z}}{\Xi, \fr{\tau}{\ss}, \fr{\tau}{\ss_1}}{\Psi}}
%\end{prooftree}
%
%\begin{prooftree}
  %\leftl{\rule{S-Case-s} :}
  %\ax{\sev{\Xi, \fr{\tau}{\scase{\ss_1}{\ss_2}, \ss}}{\Psi, \n{\suc{n}}}{\Xi, \fr{\tau}{\ss}, \fr{\tau, \n{n}}{\ss_2}}{\Psi}}
%\end{prooftree}
%

\begin{prooftree}
  \leftl{\rule{S-Ret} :}
  \ax{\sstep{\G \cons \cl{\b}{\nil}}{\Ph}{\G}{\Ph}}
\end{prooftree}

\judgement{\ssteps{\G}{\Ph}{\G'}{\Ph'}}

\begin{prooftree}
  \leftl{\rule{SS-Zero} :}
  \ax{\ssteps{\G}{\Ph}{\G}{\Ph}}
\end{prooftree}

\begin{prooftree}
  \ninf{\sstep{\G}{\Ph}{\G''}{\Ph''}}
  \ninf{\ssteps{\G''}{\Ph''}{\G'}{\Ph'}}
  \leftl{\rule{SS-More} :}
  \binf{\ssteps{\G}{\Ph}{\G'}{\Ph'}}
\end{prooftree}


\subsection*{Translation}
\ensurecommand{\trabs}[3]{\ensuremath{#1 \circ #2 \rhd #3}}
\ensurecommand{\trabsfinal}[2]{\ensuremath{#1 \rhd #2}}

We translate from De Bruijn expressions to stack programs using the following judgements.
As a shorthand \trabsfinal{b}{p} denotes \trabs{b}{[]}{p}.

\vspace{0.5cm}

\judgement{\tracc{b}{p}{p'}}

\begin{prooftree}
  \leftl{\rule{T-Num} :}
  \ax{\trabs{\n{n}}{p}{\n{n}; p}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rule{T-Var} :}
  \ax{\trabs{i}{p}{\svar{i}; p}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trabsfinal{b_1}{p_1}}
  \leftl{\rule{T-Lam} :}
  \uinf{\trabs{\blam{b_1}}{p}{(\slam{p_1}); p}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trabs{b_2}{\sapp; p}{p''}}
  \ninf{\trabs{b_1}{p''}{p'}}
  \leftl{\rule{T-App} :}
  \binf{\trabs{b_1 \app b_2}{p}{p'}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trabs{b_1}{\ssuc; p}{p'}}
  \leftl{\rule{T-Suc} :}
  \uinf{\trabs{\bsuc{b_1}}{p}{p'}}
\end{prooftree}

%% \begin{prooftree}
%% 	\ninf{\trabs{\b_3}{\nil}{p_3}}
%% 	\ninf{\trabs{\b_2}{\nil}{p_2}}
%%   \ninf{\trabs{\b_1}{\scase{p_2}{p_3}, p}{p'}}
%%   \leftl{\rule{T-Case} :}
%%   \tinf{\trabs{\bcase{\b_1}{\b_2}{\b_3}}{p}{p'}}
%% \end{prooftree}

\subsection*{Equivalence}

%% \begin{theorem} [Equivalence Bruijn-stack]
%% \label{thm:equiv-bs} If \tr{\b}{\ss}, then \hev{\nil}{\b}{\n{n}} if and only if \ev{\ss}{\n{n}}.
%% \end{theorem}

To prove this we need two additional judgements:
\vspace{0.5cm}

\judgement{\cor{\h{b}}{\h{s}}}

\begin{prooftree}
  \leftl{\rule{C-Num} :}
  \ax{\cor{\n{n}}{\n{n}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\cor{\a}{\b}}
  \ninf{\trabsfinal{b}{p}}
  \leftl{\rule{C-Fun} :}
  \binf{\cor{\cl{\a}{b}}{\cl{\b}{p}}}
\end{prooftree}

\judgement{\scomp{\sg}{\tau}}

\begin{prooftree}
  \leftl{\rule{D-Nil} :}
  \ax{\scomp{\nil}{\nil}}
\end{prooftree}

\begin{prooftree}
  \ninf{\cor{\a}{\b}}
  \ninf{\cor{\h{b}}{\h{s}}}
  \leftl{\rule{D-Cons} :}
  \binf{\cor{\a :: \h{b}}{\b :: \h{s}}}
\end{prooftree}

%% completeness
%% \begin{lemma}
%% If \tracc{\b}{\ss_2}{\ss} and \hev{\sg}{\b}{\v} with \cor{\sg}{\tau}, then (for all $\Xi$ and $\Psi$) there exists $\w$ such that \ssev{\Xi, \fr{\tau}{\ss}}{\Psi}{\Xi, \fr{\tau}{\ss_2}}{\Psi, \w} with \cor{\v}{\w}.
%% \end{lemma}

%% Let $\prec$ denote the standard subtree order on step sequences, i.e. $\P_1 \prec \P_2$ if $\P_1$ is a proper suffix of $\P_2$.

%% soundness
%% \begin{lemma}
%% If \tracc{\b}{\ss_2}{\ss} and \ssev{\Xi, \fr{\tau}{\ss}}{\Psi}{\nil}{\nil, \w'} (by $\P$) with \cor{\sg}{\tau}, then there exists $\v$ such that \hev{\sg}{\b}{\v} with \cor{\v}{\w} and \ssev{\Xi, \fr{\tau}{\ss_2}}{\Psi, \w}{\nil}{\nil, \w'} (by $\P'$) where $\P' \prec \P$.
%% \end{lemma}



\section*{Machine Language}
The next challenge we face is moving the program code to some external storage and referring to it indirectly.
% To illuminate this issue we consider a slight evolution of the stack language.
% Nevertheless, it still poses the problem of how to handle translations of subprograms when the evaluation is happening in the context of the full program.
The solution is to define a subprogram relation which carries evidence of how to arrive at the subprogram from the full program.
This evidence is used to keep track of the location of different subprograms relative to each other and to make sure that references are suitably modified to apply in a different context than they were created.

%In this language the evidence takes the form of a path through the program storage tree, but the technique seems equally applicable if we were to generate machine code directly where the evidence would be the base address of the subprogram in question.

\subsection*{Syntax}

\renewcommand{\mpushnum}[1]{\mathtt{pushnum} \; #1}%
\renewcommand{\mpushvar}[1]{\mathtt{pushvar} \; #1}%
\renewcommand{\mpushclos}[1]{\mathtt{pushclos} \; #1}%
\renewcommand{\mcall}[1]{\mathtt{call} \; #1}%
\renewcommand{\mret}{\mathtt{ret}}%
\renewcommand{\mhalt}{\mathtt{halt}}%

Let $\l$ denote program addresses (natural numbers).
We define labels machine instructions $m$ and programs $q$:
\begin{align*}
  m &\defi \mpushnum{n} \alt \mpushvar{i} \alt \mpushclos{\l} \alt \mcall{\l} \alt \mret \alt \mhalt \\
  q &\defi \nil \alt m \seq q
\end{align*}
Note that the address in the instruction $\mcall{\l}$ is the return address.

\subsection*{Semantics}

\newcommand{\hm}{\hat{m}}
\renewcommand{\D}{\Delta}%

\renewcommand{\Ps}{\Psi}%

We define values $\hm$, environments $\c$, control stacks $\D$, and value stacks $\Ps$:
\begin{align*}
  \hm &\defi \n{n} \alt \cl{\c}{\l} \\
  \c &\defi \nil \alt \c \cons \hm \\
  \D &\defi \nil \alt \D \cons \cl{\c}{\l} \\
  \Ps &\defi \nil \alt \Ps \cons \hm
\end{align*}

We need a judgement for variable lookup (rules as expected):

\newcommand{\mlook}[3]{\ensuremath{#1 \vdash #2 \uparrow #3}}

\vspace{0.5cm}
\judgement{\mlook{\c}{i}{\hm}}

% write the rules here

%\vspace{0.5cm}
%\judgement{$\q \vdash \l \uparrow \b$}
%\vspace{0.5cm}

And an execution judgement:

\renewcommand{\mexec}[8]{\ensuremath{#1, #2 \vdash \tup{#3, #4, #5} \rightarrow \tup{#6, #7, #8}}}%

\newcommand{\lret}{\l_{\mathrm{ret}}}

\vspace{0.5cm}
\judgement{\mexec{q}{m}{\D}{\l}{\Ps}{\D'}{\l'}{\Ps'}}

\begin{prooftree}
  \ax{\mexec{q}{\mpushnum{n}}{\D}{\l}{\Ps}{\D}{\l + 1}{\Ps \cons \n{n}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\mlook{\c}{i}{\hm}}
  \uinf{\mexec{q}{\mpushvar{i}}{\D}{\l}{\Ps}{\D}{\l + 1}{\Ps \cons \hm}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{q}{\mpushclos{\l'}}{\D \cons \cl{\c}{\lret}}{\l}{\Ps}{\D \cons \cl{\c}{\lret}}{\l + 1}{\Ps \cons \cl{\c}{\l'}}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{q}{\mcall{\lret}}{\D}{\l}{\Ps \cons \cl{\c'}{\l'} \cons \hm}{\D \cons \cl{\c' \cons \hm}{\lret}}{\l'}{\Ps}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{q}{\mret}{\D \cons \cl{\c}{\lret}}{\l}{\Ps}{\D}{\lret}{\Ps}}
\end{prooftree}

And finally the multi-step judgement:

\newcommand{\msteps}[7]{\ensuremath{#1 \vdash \tup{#2, #3, #4} \rightarrow^* \tup{#5, #6, #7}}}

\vspace{0.5cm}
\judgement{\msteps{q}{\D}{\l}{\Ps}{\D'}{\l'}{\Ps'}}
\vspace{0.5cm}

\begin{prooftree}
  \leftl{\rule{MS-Zero} :}
  \ax{\msteps{q}{\D}{\l}{\Ps}{\D}{\l}{\Ps}}
\end{prooftree}

\begin{prooftree}
  \ninf{\mexec{q}{m}{\D}{\l}{\Ps}{\D''}{\l''}{\Ps''}}
  \ninf{\msteps{q}{\D''}{\l''}{\Ps''}{\D'}{\l'}{\Ps'}}
  \leftl{\rule{MS-More} :}
	\rightl{$(q(\l) = m)$}
  \binf{\msteps{q}{\D}{\l}{\Ps}{\D'}{\l'}{\Ps'}}
\end{prooftree}
where $q(\l)$ denotes the $\l$'th instruction of the program $q$.




%
%
%And a complete evaluation judgement:
%
%\vspace{0.5cm}
%\judgement{$\tup{\b ; \q} \downarrow \r$}
%
%\begin{prooftree}
  %\ninf{\mstep{\q}{\mnil, \tup{\mnil; \ldone}}{\b}{\mnil}{\mnil}{\mhalt}{\mnil, \r}}
  %\uinf{$\tup{\b ; \q} \downarrow \r$}
%\end{prooftree}
%
%\subsection*{Translation}

\newcommand{\trasm}[3]{#1 \rhd \tup{#2 ; #3}}

%
%Let $f, g$ denote functions on labels, e.g. $\lnext$.
%Let $f(\q)$ denote the label-program $\q$ with $f$ applied to each label.
%
%We translate from stack programs to label-machine programs using the following judgement:
%
%\vspace{0.5cm}
%\judgement{$\trasl{\ss}{\b}{\q}$}
%
%\begin{prooftree}
  %\ninf{$\trasl{\ss}{\b}{\q}$}
  %\uinf{$\trasl{\snum{n}, \ss}{\mpushnum{n}, \b}{\q}$}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\trasl{\ss}{\b}{\q}$}
  %\uinf{$\trasl{\svar{i}, \ss}{\mpushvar{i}, \b}{\q}$}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\trasl{\ss}{\b}{\q}$}
  %\ninf{$\trasl{\ss_0}{\b_0}{\q_0}$}
  %\binf{$\trasl{\slam{\ss_0}, \ss}{\mpushclos{(\lright \; \lhere)}, \lleft(\b)}{\lleft(\q) \mnode \lright(\lnext(\b_0 \mcons \q_0))}$}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\trasl{\ss}{\b}{\q}$}
  %\uinf{$\trasl{\sapp, \ss}{\mcall{\lhere}}{\lnext(\b \mcons \q)}$}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{$\trasl{\ssnil}{\mret}{\mnil}$}
%\end{prooftree}
%
%\subsection*{Equivalence}
%
%\begin{theorem} [Equivalence Stack-Label]
%\label{thm:equiv-sl} If $\trasl{\ss}{\b}{\q}$, then $\ev{\ss}{\n{n}}$ if and only if $\tup{\b ; \q} \downarrow \n{n}$.
%\end{theorem}
%
%To prove this, we need some correspondence judgements:
%
%\newcommand{\corvalue}[3]{#1 \vdash #2 \rightsquigarrow #3}
%\newcommand{\corstore}{\corvalue}
%\newcommand{\corvaluestack}{\corstore}
%\newcommand{\corstack}[4]{#1 \vdash #2 \rightsquigarrow \tup{#3 ; #4}}
%
%\vspace{0.5cm}
%\judgement{$\q' \leq_{f} \q$}
%
%\begin{prooftree}
  %\leftl{\rule{Leq-Left} :}
  %\ax{$\q' \leq_{\lleft} \lleft(\q') \mnode \q_2 $}
%\end{prooftree}
%
%\begin{prooftree}
  %\leftl{\rule{Leq-Right} :}
  %\ax{$\q' \leq_{\lright} \q_1 \mnode \lright(\q') $}
%\end{prooftree}
%
%\begin{prooftree}
  %\leftl{\rule{Leq-Next} :}
  %\ax{$\q' \leq_{\lnext} \b \mcons \lnext(\q') $}
%\end{prooftree}
%
%\begin{prooftree}
  %\leftl{\rule{Leq-Refl} :}
  %\ax{$\q' \leq_{(\l \mapsto \l)} \q' $}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\q' \leq_{f} \q'' $}
  %\ninf{$\q'' \leq_{g} \q' $}
  %\leftl{\rule{Leq-Trans} :}
  %\binf{$\q' \leq_{(g \circ f)} \q $}
%\end{prooftree}
%%
%where $\circ$ denotes function composition.
%
%\vspace{0.5cm}
%\judgement{$\corvalue{\q}{\w}{\r}$}
%
%\begin{prooftree}
  %\leftl{\rule{C-Num} :}
  %\ax{$\corvalue{\q}{\n{n}}{\n{n}}$}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\corstore{\q}{\tau}{\a}$}
  %\ninf{$\q \vdash \l \uparrow f(\b')$}
  %\ninf{$\trasl{\ss}{\b'}{\q'}$}
  %\ninf{$\q' \leq_{f} \q$}
  %\leftl{\rule{C-Clos} :}
  %\qinf{$\corvalue{\q}{\cl{\tau}{\ss}}{\cl{\a}{\l}}$}
%\end{prooftree}
%
%\vspace{0.5cm}
%\judgement{$\corstore{\q}{\tau}{\a}$}
%
%\begin{prooftree}
  %\leftl{\rule{D-Nil} :}
  %\ax{$\corstore{\q}{\mnil}{\mnil}$}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\corstore{\q}{\tau}{\a}$}
  %\ninf{$\corvalue{\q}{\w}{\r}$}
  %\leftl{\rule{D-Cons} :}
  %\binf{$\corstore{\q}{\tau, \w}{\a, \r}$}
%\end{prooftree}
%
%\vspace{0.5cm}
%\judgement{$\corvaluestack{\q}{\Psi}{\Phi}$}
%\vspace{0.5cm}
%
%(same rules as previous judgement)
%
%\vspace{0.5cm}
%\judgement{$\corstack{\q}{\Xi}{\b}{\Gamma}$}
%
%\begin{prooftree}
  %\ax{$\corstack{\q}{\mnil}{\mhalt}{\mnil}$}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\corstack{\q}{\Xi}{\b}{\Gamma}$}
  %\ninf{$\corstore{\q}{\tau}{\a}$}
  %\ninf{$\q \vdash \l \uparrow \b$}
  %\ninf{$\trasl{\ss}{\b'}{\q'}$}
  %\ninf{$\q' \leq_{f} \q$}
  %\fiveinf{$\corstack{\q}{\Xi, \tup{\tau ; \ss}}{f(\b')}{\Gamma, \tup{\a; \l}}$}
%\end{prooftree}
%
%\vspace{0.5cm}
%
%And now we are ready to generalise completeness and soundness:
%
%% completeness
%\begin{lemma}
%If $\ssev{\Xi}{\Psi}{\mnil}{\mnil, \w}$, $\corstack{\q}{\Xi}{\b}{\Gamma}$ and $\corvaluestack{\q}{\Psi}{\Phi}$, then there exists $\r$ such that $\msteps{\q}{\Gamma}{\b}{\Phi}{\mnil}{\mhalt}{\mnil, \r}$ with $\corvalue{\q}{\w}{\r}$.
%\end{lemma}
%
%% soundness
%\begin{lemma}
%If $\msteps{\q}{\Gamma}{\b}{\Phi}{\mnil}{\mhalt}{\mnil, \r}$, $\corstack{\q}{\Xi}{\b}{\Gamma}$ and $\corvaluestack{\q}{\Psi}{\Phi}$, then there exists $\w$ such that $\ssev{\Xi}{\Psi}{\mnil}{\mnil, \w}$ with $\corvalue{\q}{\w}{\r}$.
%\end{lemma}


















%\section*{Machine Language}
%
%\subsection*{Syntax}
%\begin{align*}
  %\o &\defi \z \alt \suc \o \\
  %\r &\defi \n{n} \alt \rpaddr{n} \alt \rhaddr{n} \alt \rundef \\
  %\m &\defi \mload{\o} \alt \mstore{\o} \alt \malloc{n} \alt \mpeek{n} \alt \mpushnum{n} \alt \mpushpaddr{k} \\
     %&\quad \quad \quad \quad \,\,\,\, \alt \mnewframe \alt \mendframe \alt \mgetarg \alt \mgetenv \alt \mgetret \\
     %&\quad \quad \quad \quad \,\,\,\, \alt \mjump \alt \mgetaddr{\o} \alt \mhalt \\
  %\q &\defi \mend \alt \m ; \q
%\end{align*}
%
%\subsection*{Semantics}
%\begin{align*}
  %(\text{register set}) \; \Phi &\defi \nil \alt \Phi, \r \\
  %(\text{frame}) \; \f &\defi \mfr{\Phi}{\r_1}{\r_2}{\r_3} \\
  %(\text{call stack}) \; \Gamma &\defi \nil \alt \Gamma, \f \\
  %(\text{memory block}) \; \B &\defi \nil \alt \r, \B \\
  %(\text{heap}) \; \H &\defi \nil \alt \B, \H
%\end{align*}
%
%[To what extent should we define these formally as judgements? Perhaps it suffices to explain their, for the most part obvious, semantics in text.]
%
%\vspace{0.5cm}
%
%\judgement{$\mathtt{reg{-}peek} \; \Phi \; n \; \r$}
%\judgement{$\mathtt{prog{-}fetch} \; \q \; \k \; \m$}
%\judgement{$\mathtt{block{-}fetch} \; \B \; \o \; \r$}
%\judgement{$\mathtt{block{-}alloc} \; n \; \B$}
%\judgement{$\mathtt{block{-}update} \; \B \; \o \; \r \; \B'$}
%\judgement{$\mathtt{heap{-}fetch} \; \H \; a \; \o \; \r$}
%\judgement{$\mathtt{heap{-}update} \; \H \; a \; \o \; \r \; \H'$}
%\judgement{$\mathtt{heap{-}alloc} \; \H \; n \; \H' \; a$}
%
%\vspace{0.5cm}
%
%\judgement{\meval{\q}{\k}{\r}}
%
%\begin{prooftree}
  %\ninf{\mmev{\q}{\nil}{\nil}{\mathtt{simple{-}frame}(\nil)}{\k}{\H'}{\nil}{\mathtt{simple{-}frame}(\nil, \r)}{\k'}}
  %\ninf{$\mathtt{prog{-}fetch} \; \q \; \k' \; \mhalt$}
  %\binf{\meval{\q}{\k}{\r}}
%\end{prooftree}
%
%where $\mathtt{simple{-}frame}(\Phi)$ denotes
%\[ \mfr{\Phi}{\rundef}{\rundef}{\rundef} \]
%
%\vspace{0.5cm}
%
%\judgement{\mev{\q}{\H}{\Gamma}{\f}{\k}{\H'}{\Gamma'}{\f'}{\k'}}
%
%\begin{prooftree}
  %\ninf{$\mathtt{prog{-}fetch} \; \q \; \k \; \m$}
  %\ninf{\mexec{\m}{\H}{\Gamma}{\f}{\k}{\H'}{\Gamma'}{\f'}{\k'}}
  %\binf{\mev{\q}{\H}{\Gamma}{\f}{\k}{\H'}{\Gamma'}{\f'}{\k'}}
%\end{prooftree}
%
%\vspace{0.5cm}
%
%\judgement{\mmev{\q}{\H}{\Gamma}{\f}{\k}{\H'}{\Gamma'}{\f'}{\k'}}
%
%\vspace{0.5cm}
%
%[defined as usual]
%
%\vspace{0.5cm}
%
%%tmp
%\newcommand{\fram}[4]{\mathtt{fr} \; #1 \; #2 \; #3 \; #4}
%
%Let now $\fram{\Phi}{\r_1}{\r_2}{\r_3}$ denote
%\[ \mfr{\Phi}{\r_1}{\r_2}{\r_3} \]
%
%\judgement{\mexec{\m}{\H}{\Gamma}{\f}{\k}{\H'}{\Gamma'}{\f'}{\k'}}
%
%\begin{prooftree}
  %\ninf{$\mathtt{heap{-}fetch} \; \H \; a \; \o \; \r$}
  %\uinf{\mexec{\mload{\o}}{\H}{\Gamma}{\fram{(\Phi, \rhaddr{a})}{\r_1}{\r_2}{\r_3}}{\k}{\H}{\Gamma}{\fram{(\Phi, \r)}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\mathtt{heap{-}update} \; \H \; a \; \o \; \r \; \H'$}
  %\uinf{\mexec{\mstore{\o}}{\H}{\Gamma}{\fram{(\Phi, \rhaddr{a}, \r)}{\r_1}{\r_2}{\r_3}}{\k}{\H'}{\Gamma}{\fram{(\Phi, \rhaddr{a})}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\mathtt{heap{-}alloc} \; \H \; n \; \H' \; a$}
  %\uinf{\mexec{\malloc{n}}{\H}{\Gamma}{\fram{\Phi}{\r_1}{\r_2}{\r_3}}{\k}{\H'}{\Gamma}{\fram{(\Phi, \rhaddr{a})}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\mathtt{reg{-}peek} \; \Phi \; n \; \r$}
  %\uinf{\mexec{\mpeek{n}}{\H}{\Gamma}{\fram{\Phi}{\r_1}{\r_2}{\r_3}}{\k}{\H}{\Gamma}{\fram{(\Phi, \r)}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\mexec{\mpushnum{n}}{\H}{\Gamma}{\fram{\Phi}{\r_1}{\r_2}{\r_3}}{\k}{\H}{\Gamma}{\fram{(\Phi, \n{n})}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\mexec{\mpushpaddr{k'}}{\H}{\Gamma}{\fram{\Phi}{\r_1}{\r_2}{\r_3}}{\k}{\H}{\Gamma}{\fram{(\Phi, \rpaddr{k'})}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\mexec{\mnewframe}{\H}{\Gamma}{\fram{(\Phi, \r_1', \r_2', \r_3', \r)}{\r_1}{\r_2}{\r_3}}{\k}{\H}{(\Gamma, \fram{\Phi}{\r_1}{\r_2}{\r_3})}{\fram{(\nil, \r)}{\r_1'}{\r_2'}{\r_3'}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\mexec{\mendframe}{\H}{(\Gamma, \fram{\Phi}{\r_1}{\r_2}{\r_3})}{\fram{(\nil, \r)}{\r_1'}{\r_2'}{\r_3'}}{\k}{\H}{\Gamma}{\fram{(\Phi, \r)}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\mexec{\mgetenv}{\H}{\Gamma}{\fram{\Phi}{\r_1}{\r_2}{\r_3}}{\k}{\H}{\Gamma}{\fram{(\Phi, \r_1)}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\mexec{\mgetarg}{\H}{\Gamma}{\fram{\Phi}{\r_1}{\r_2}{\r_3}}{\k}{\H}{\Gamma}{\fram{(\Phi, \r_2)}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\mexec{\mgetret}{\H}{\Gamma}{\fram{\Phi}{\r_1}{\r_2}{\r_3}}{\k}{\H}{\Gamma}{\fram{(\Phi, \r_3)}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\mexec{\mjump}{\H}{\Gamma}{\fram{(\Phi, \rpaddr{\k'})}{\r_1}{\r_2}{\r_3}}{\k}{\H}{\Gamma}{\fram{\Phi}{\r_1}{\r_2}{\r_3}}{\k'}}
%\end{prooftree}
%
%\begin{prooftree}
  %\rightl{$(\k' = \k + \o)$}
  %\ax{\mexec{\mgetaddr{\o}}{\H}{\Gamma}{\fram{\Phi}{\r_1}{\r_2}{\r_3}}{\k}{\H}{\Gamma}{\fram{(\Phi, \rpaddr{\k'})}{\r_1}{\r_2}{\r_3}}{\k + 1}}
%\end{prooftree}
%
%% No rule for halt!
%
%\subsection*{Translation}
%Let $|i|$ denote the numeric value of a De Bruijn index.
%
%\vspace{0.5cm}
%
%\judgement{\transsm{\ss}{\q}{\k}}
%
%\begin{prooftree}
  %\ninf{$\trm{\z}{\nil}{\nil}{\ss}{\hq}{\q}$}
  %\rightl{$(\k = \mathtt{length} \; (\hq ; \mend))$}
  %\uinf{\transsm{\ss}{(\hq ; \q ; \mhalt ; \mend)}{\k}}
%\end{prooftree}
%
%\vspace{0.5cm}
%
%\judgement{\trm{\k}{\hq}{\q}{\ss}{\hq'}{\q'}}
%
%\begin{prooftree}
  %\ax{\trm{\k}{\hq}{\q}{\nil}{\hq}{\q}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{$\trm{\k}{\hq}{\q}{\s}{\hq''}{\q''}$}
  %\ninf{$\trm{\k}{\hq''}{\q''}{\ss}{\hq'}{\q'}$}
  %\binf{\trm{\k}{\hq}{\q}{(\s, \ss)}{\hq'}{\q'}}
%\end{prooftree}
%
%\vspace{0.5cm}
%
%\judgement{\trm{\k}{\hq}{\q}{\s}{\hq'}{\q'}}
%
%\begin{prooftree}
  %\ax{\trm{\k}{\hq}{\q}{\n{n}}{\hq}{(\q ; \mpushnum{n})}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\trm{\k}{\hq}{\q}{\z}{\hq}{(\q ; \mgetarg)}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\trm{\k}{\hq}{\q}{(\suc{i})}{\hq}{(\q ; \mgetenv ; \mload{(\suc i)})}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ninf{\trm{\k + 1}{\hq}{\nil}{\ss_1}{\hq'}{\q'}}
  %\ninf{$\mathtt{trans{-}copy} \; \k \; 1 \; \hq''$}
  %\rightl{$(\k' = \mathtt{length} \; (\hq' ; \mend))$}
  %\binf{\trm{\k}{\hq}{\q}{(\lam{}{\ss_1})}{(\hq' ; \q' ; \mgetret ; \mjump)}{(\q ; \mathtt{make{-}clos} \; \k \; I \; \hq'')}}
%\end{prooftree}
%
%\begin{prooftree}
  %\ax{\trm{\k}{\hq}{\q}{\sapp}{\hq}{(\q ; \mathtt{make{-}call})}}
%\end{prooftree}
%
%%\begin{prooftree}
%%\ax{\trm{\hq}{\q}{\sapp}{\hq}{\q, \mathbf{call}}}
%%\end{prooftree}
%%where $\mathbf{call}$ is
%%\begin{align*}
  %%&\transfer \\
  %%&\vdup \\
  %%&\transfer \\
  %%&\getaddr 5 \\
  %%&\transfer \\
  %%&\load 0 \\
  %%&\transfer \\
  %%&\jump \\
  %%&\cpop \\
  %%&\cpop \\
%%\end{align*}
%
%\section*{Conclusion}
%
%\ldots
%
%\section*{Future Work}
%
%\ldots

\end{document}
