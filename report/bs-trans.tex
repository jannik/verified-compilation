\subsection{Translation}

We translate from \blang expressions to \slang programs using the following judgement.
As a shorthand, \trabsfinal{\bexp}{\sprog} denotes \trabs{\bexp}{\send}{\sprog}.
% Andrzej still does not like the shorthand. consider again if it's worth it.

\vspace{0.5cm}

\judgement{\trabs{\bexp}{\sprog}{\sprog'}}

\begin{prooftree}
  \leftl{\rule{T-Num} :}
  \ax{\trabs{\n{\nat}}{\sprog}{\n{\nat} \sseq \sprog}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rule{T-Var} :}
  \ax{\trabs{\bvar}{\sprog}{\svar{\bvar} \sseq \sprog}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trabsfinal{\bexp_1}{\sprog_1}}
  \leftl{\rule{T-Lam} :}
  \uinf{\trabs{\blam{\bexp_1}}{\sprog}{\slam{\sprog_1} \sseq \sprog}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trabs{\bexp_2}{\sapp \sseq \sprog}{\sprog''}}
  \ninf{\trabs{\bexp_1}{\sprog''}{\sprog'}}
  \leftl{\rule{T-App} :}
  \binf{\trabs{\bapp{\bexp_1}{\bexp_2}}{\sprog}{\sprog'}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trabs{\bexp_1}{\ssuc \sseq \sprog}{\sprog'}}
  \leftl{\rule{T-Suc} :}
  \uinf{\trabs{\bsuc{\bexp_1}}{\sprog}{\sprog'}}
\end{prooftree}

% Since a \blang expression corresponds to a list of \slang instructions, i.e. a \slang program, it is convenient to ... something something accumulator.
If \trabs{\bexp}{\sprog}{\sprog'}, then $\sprog'$ is the translation of $\bexp$ put in front of the accumulator $\sprog$.
This avoids having to reason about concatenation of programs in the equivalence proof.
% .. is a common technique used e.g. when proving x. [ref]. or perhaps not worth mentioning.

Unlike the previous translation, from \hlang to \blang, this translation is clearly total.
That is, for every \blang expression $\bexp$ there exists a \slang program $\sprog$ such that \trabsfinal{\bexp}{\sprog}.

% \Twelf agrees.
% Concatenation is painful in Twelf, hence accumulator.
