\subsection{Translation}

We translate from \blang expressions to \slang programs using the following judgement.
As a shorthand, \trabsfinal{\bexp}{\sprog} denotes \trabs{\bexp}{\send}{\sprog}.
% Andrzej still does not like the shorthand. consider again if it's worth it.

\vspace{0.5cm}

\judgement{\trabs{\bexp}{\sprog}{\sprog'}}

\begin{prooftree}
  \leftl{\rule{T-Num} :}
  \ax{\trabs{\n{\nat}}{\sprog}{\n{\nat} \sseq \sprog}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rule{T-Var} :}
  \ax{\trabs{\bvar}{\sprog}{\svar{\bvar} \sseq \sprog}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trabsfinal{\bexp_1}{\sprog_1}}
  \leftl{\rule{T-Lam} :}
  \uinf{\trabs{\blam{\bexp_1}}{\sprog}{\slam{\sprog_1} \sseq \sprog}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trabs{\bexp_2}{\sapp \sseq \sprog}{\sprog''}}
  \ninf{\trabs{\bexp_1}{\sprog''}{\sprog'}}
  \leftl{\rule{T-App} :}
  \binf{\trabs{\bapp{\bexp_1}{\bexp_2}}{\sprog}{\sprog'}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trabs{\bexp_1}{\ssuc \sseq \sprog}{\sprog'}}
  \leftl{\rule{T-Suc} :}
  \uinf{\trabs{\bsuc{\bexp_1}}{\sprog}{\sprog'}}
\end{prooftree}

If \trabs{\bexp}{\sprog}{\sprog'}, then intuitively speaking $\sprog'$ is the translation of $\bexp$ put in front of the accumulator $\sprog$.
This avoids having to reason about concatenation of programs in the equivalence proof.

Unlike the previous translation, from \hlang to \blang, this translation is clearly total.
That is, for every \blang expression $\bexp$ there exists a \slang program $\sprog$ such that \trabsfinal{\bexp}{\sprog}.

\Twelf
Totality is supported by Twelf accepting a \texttt{\%total} declaration on the translation judgement.
Note that the accumulator strategy is especially suited to mechanisation in Twelf --- working with a concatenation relation is bothersome since we must argue explicitly that it is a function and prove e.g. associativity.
