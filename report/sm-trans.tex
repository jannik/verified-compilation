\subsection*{Translation}

\ensurecommand{\trasm}[2]{\ensuremath{#1 \mathrel{\rhd} #2}}
\ensurecommand{\trasmfinal}[3]{\ensuremath{#1 \mathrel{\rhd} \tup{#2 \tupsep #3}}}

\ensurecommand{\shift}[2]{(#1 \gg #2)} % or perhaps {#1^{\wedge #2}}
\ensurecommand{\len}[1]{\left| #1 \right|}

%Let $f, g$ denote functions on labels, e.g. $\lnext$.
%Let $f(\q)$ denote the label-program $\q$ with $f$ applied to each label.

Let $\shift{\mprog}{\nat}$ denote the program $\mprog$ shifted by $\nat$, i.e. with each address $\addr$ replaced by $\addr + \nat$.
We translate from stack programs to machine programs using the following judgements:

\vspace{0.5cm}

\judgement{$\trasmfinal{\sprog}{\mprog}{\addr}$}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasmfinal{\sprog}{\mhalt \mseq \shift{\mprog}{1}}{1}$}
\end{prooftree}

\vspace{0.5cm}

\judgement{$\trasm{\sprog}{\mprog}$}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasm{\snum{\nat} \sseq \sprog}{\mpushnum{\nat} \mseq \shift{\mprog}{1}}$}
\end{prooftree}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasm{\svar{\bvar} \sseq \sprog}{\mpushvar{\bvar} \mseq \shift{\mprog}{1}}$}
\end{prooftree}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \ninf{$\trasm{\sprog_0}{\mprog_0}$}
  \binf{$\trasm{\slam{\sprog_0} \sseq \sprog}{\mpushclos{(\len{\mprog} + 1)} \mseq \shift{\mprog}{1} \mconcat \shift{\mprog_0}{(\len{\mprog} + 1)}}$}
\end{prooftree}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasm{\sapp \sseq \sprog}{\mcall{1} \mseq \shift{\mprog}{1}}$}
\end{prooftree}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasm{\ssuc \sseq \sprog}{\minc \mseq \shift{\mprog}{1}}$}
\end{prooftree}

\begin{prooftree}
  \ax{$\trasm{\send}{\mret \mseq \mend}$}
\end{prooftree}
