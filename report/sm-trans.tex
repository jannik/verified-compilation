\subsection{Translation}

Let $\shift{\mprog}{\nat}$ denote the program $\mprog$ shifted by $\nat$, i.e. with each address $\addr$ (in $\mpushclos{\addr}$ and $\mcall{\addr}$) replaced by $\addr + \nat$.
We translate from stack programs to machine programs using the following judgements:

\vspace{0.5cm}

\judgement{$\trasmfinal{\sprog}{\mprog}{\addr}$}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasmfinal{\sprog}{\mhalt \mseq \shift{\mprog}{1}}{1}$}
\end{prooftree}

\vspace{0.5cm}

\judgement{$\trasm{\sprog}{\mprog}$}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasm{\snum{\nat} \sseq \sprog}{\mpushnum{\nat} \mseq \shift{\mprog}{1}}$}
\end{prooftree}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasm{\svar{\bvar} \sseq \sprog}{\mpushvar{\bvar} \mseq \shift{\mprog}{1}}$}
\end{prooftree}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \ninf{$\trasm{\sprog_0}{\mprog_0}$}
  \binf{$\trasm{\slam{\sprog_0} \sseq \sprog}{\mpushclos{(\len{\mprog} + 1)} \mseq \shift{\mprog}{1} \mconcat \shift{\mprog_0}{(\len{\mprog} + 1)}}$}
\end{prooftree}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasm{\sapp \sseq \sprog}{\mcall{1} \mseq \shift{\mprog}{1}}$}
\end{prooftree}

\begin{prooftree}
  \ninf{$\trasm{\sprog}{\mprog}$}
  \uinf{$\trasm{\ssuc \sseq \sprog}{\minc \mseq \shift{\mprog}{1}}$}
\end{prooftree}

\begin{prooftree}
  \ax{$\trasm{\send}{\mret \mseq \mend}$}
\end{prooftree}

This translation is clearly total; for every \slang program $\sprog$ there exists a \mlang program $\mprog$ and an address $\addr$ such that \trasmfinal{\sprog}{\mprog}{\addr}.

% mention: quadratic but equivalent to simpler linear. but (perhaps) this translation is easier to prove things about.

\Twelf
Twelf does indeed accept a \texttt{\%total} declaration on the translation judgement.
% something about shifts as a judgement?
