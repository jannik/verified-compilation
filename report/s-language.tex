\section{The \textnormal{\slang} Language}

We now develop the next translation target, \slang.
Where \blang expressions have a tree structure, \slang programs are flat lists of mostly atomic instructions.
(Functions will be flattened in the next translation.)
Computation uses abstract stack machine semantics, replacing a big-step evaluation tree with a flat sequence of states.


\subsection{Syntax}

We define stack-machine instructions $\sinst$ and programs $\sprog$:
\begin{align*}
  \sinst &\defi \snum{\nat} \alt \svar{\bvar} \alt \slam{\sprog} \alt \sapp \alt \ssuc \\
  \sprog &\defi \send \alt \sinst \sseq \sprog
\end{align*}
(Note that $\bvar$ was defined previously.)


\subsection{Semantics}

We define values $\sval$, environments $\senv$, control stacks $\sctrl$, and value stacks $\svals$:
\begin{align*}
  \sval &\defi \n{\nat} \alt \cl{\senv}{\sprog} \\
  \senv &\defi \envnil \alt \senv \envcons \sval \\
  \sctrl &\defi \stknil \alt \sctrl \stkcons \fr{\senv}{\sprog} \\
  \svals &\defi \stknil \alt \svals \stkcons \sval
\end{align*}

And the semantics judgements:
\vspace{0.5cm}

\judgement{\slook{\senv}{\bvar}{\sval}}

\begin{prooftree}
  \leftl{\rulename{Sv-Here} :}
  \ax{\slook{\senv \envcons \sval}{\z}{\sval}}
\end{prooftree}

\begin{prooftree}
  \ninf{\slook{\senv}{\bvar}{\sval}}
  \leftl{\rulename{Sv-There} :}
  \uinf{\slook{\senv \envcons \sval'}{\suc{\bvar}}{\sval}}
\end{prooftree}

\judgement{\sstep{\sctrl}{\svals}{\sctrl'}{\svals'}}

\begin{prooftree}
  \leftl{\rulename{S-Num} :}
  \ax{\sstep{\sctrl \stkcons \fr{\senv}{\snum{\nat} \sseq \sprog}}{\svals}{\sctrl \stkcons \fr{\senv}{\sprog}}{\svals \stkcons \n{\nat}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\slook{\senv}{\bvar}{\sval}}
  \leftl{\rulename{S-Var} :}
  \uinf{\sstep{\sctrl \stkcons \fr{\senv}{\svar{\bvar} \sseq \sprog}}{\svals}{\sctrl \stkcons \fr{\senv}{\sprog}}{\svals \stkcons \sval}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{S-Lam} :}
  \ax{\sstep{\sctrl \stkcons \fr{\senv}{\slam{\sprog_1} \sseq \sprog}}{\svals}{\sctrl \stkcons \fr{\senv}{\sprog}}{\svals \stkcons \cl{\senv}{\sprog_1}}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{S-App} :}
  \ax{\sstep{\sctrl \stkcons \fr{\senv}{\sapp \sseq \sprog}}{\svals \stkcons \cl{\senv'}{\sprog_1} \stkcons \sval_2}{\sctrl \stkcons \fr{\senv}{\sprog} \stkcons \fr{\senv' \stkcons \sval_2}{\sprog_1}}{\svals}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{S-Suc} :}
  \ax{\sstep{\sctrl \stkcons \fr{\senv}{\ssuc \sseq \sprog}}{\svals \stkcons \n{\nat}}{\sctrl \stkcons \fr{\senv}{\sprog}}{\svals \stkcons \n{\nat + 1}}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{S-Ret} :}
  \ax{\sstep{\sctrl \stkcons \fr{\senv}{\send}}{\svals}{\sctrl}{\svals}}
\end{prooftree}

\judgement{\ssteps{\sctrl}{\svals}{\sctrl'}{\svals'}}

\begin{prooftree}
  \leftl{\rulename{SS-Zero} :}
  \ax{\ssteps{\sctrl}{\svals}{\sctrl}{\svals}}
\end{prooftree}

\begin{prooftree}
  \ninf{\sstep{\sctrl}{\svals}{\sctrl''}{\svals''}}
  \ninf{\ssteps{\sctrl''}{\svals''}{\sctrl'}{\svals'}}
  \leftl{\rulename{SS-More} :}
  \binf{\ssteps{\sctrl}{\svals}{\sctrl'}{\svals'}}
\end{prooftree}

As an abbreviation, let \sev{\sprog}{\sval} denote \ssteps{[\fr{\envnil}{\sprog}]}{\stknil}{\stknil}{[\sval]}.
