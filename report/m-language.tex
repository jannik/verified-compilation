\section{The \textnormal{\mlang} Language}

The distinguishing feature of \mlang is that the program is fully linearised and is not consumed during execution.
Rather, instructions are fetched from a program store which is kept static.
Like \slang, \mlang has abstract stack machine semantics.

\subsection{Syntax}

The syntax of \mlang is flat, even functions are represented merely by references to parts of the full program, i.e. addresses.
Let $\addr$ denote program addresses (natural numbers).
We define \mlang instructions $\minst$ and programs $\mprog$:
\begin{align*}
  \minst &\defi \mpushnum{\nat} \alt \mpushvar{\bvar} \alt \mpushclos{\addr} \alt \mcall \alt \minc \alt \mret \alt \mhalt \\
  \mprog &\defi \mend \alt \minst \mseq \mprog
\end{align*}
Note that the return address of a function call is always the address immediately following the $\mcall$ instruction.
And let $\mprog_1 \mconcat \mprog_2$ denote the concatenation of programs $\mprog_1$ and $\mprog_2$.

The abundance of syntax indicating termination warrants an explanation.
$\mret$ is for returning from a function call.
$\mhalt$, however, is for ending the entire program.
(To treat all stack frames uniformly, the top-level also ends with a $\mret$ instruction).
And $\mend$ signifies the end of the program store --- it should never be reached during execution.


\subsection{Semantics}

We define values $\mval$, environments $\menv$, control stacks $\mctrl$, and value stacks $\mvals$:
\begin{align*}
  \mval &\defi \n{\nat} \alt \cl{\menv}{\addr} \\
  \menv &\defi \envnil \alt \menv \envcons \mval \\
  \mctrl &\defi \stknil \alt \mctrl \stkcons \fr{\menv}{\addr} \\
  \mvals &\defi \stknil \alt \mvals \stkcons \mval
\end{align*}

As usual, we need a judgement for variable lookup:

\begin{judgement}{\mlook{\menv}{\bvar}{\mval}}
{the value $\mval$ is found at index $\bvar$ in $\menv$}
%
\begin{prooftree}
  \ax{\slook{\menv \envcons \mval}{\z}{\mval}}
\end{prooftree}

\begin{prooftree}
  \ninf{\slook{\menv}{\bvar}{\mval}}
  \uinf{\slook{\menv \envcons \mval'}{\suc{\bvar}}{\mval}}
\end{prooftree}
%
\end{judgement}

We then define judgements for execution:

\begin{judgement}{\mexec{\minst}{\mctrl}{\addr}{\mvals}{\mctrl'}{\addr'}{\mvals'}}
{executing $\minst$ brings the state $\tup{\mctrl \tupsep \addr \tupsep \mvals}$ to $\tup{\mctrl' \tupsep \addr' \tupsep \mvals'}$}
%
\begin{prooftree}
  \ax{\mexec{\mpushnum{\nat}}{\mctrl}{\addr}{\mvals}{\mctrl}{\addr + 1}{\mvals \stkcons \n{\nat}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\mlook{\menv}{\bvar}{\mval}}
  \uinf{\mexec{\mpushvar{\bvar}}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr}{\mvals}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr + 1}{\mvals \stkcons \mval}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{\mpushclos{\addr'}}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr}{\mvals}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr + 1}{\mvals \stkcons \cl{\menv}{\addr'}}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{\mcall}{\mctrl}{\addr}{\mvals \stkcons \cl{\menv'}{\addr'} \stkcons \mval}{\mctrl \stkcons \fr{\menv' \envcons \mval}{\addr + 1}}{\addr'}{\mvals}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{\minc}{\mctrl}{\addr}{\mvals \stkcons \n{\nat}}{\mctrl}{\addr + 1}{\mvals \stkcons \n{\nat + 1}}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{\mret}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr}{\mvals}{\mctrl}{\addrret}{\mvals}}
\end{prooftree}

(No rule for \texttt{halt}!)
%
\end{judgement}


%msteps : mprog -> mframes -> label -> rstack -> mvalue -> type. %name msteps DMM.
%%mode msteps +Q +Delta +L +Phi -R.
%
%msteps/zero : msteps Q Delta L (rstack/single R) R
%               <- label-lookup Q L mhalt.
%
%msteps/more : msteps Q Delta L Phi R
%               <- label-lookup Q L M
%               <- mstep M Delta L Phi Delta' L' Phi'
%               <- msteps Q Delta' L' Phi' R.
%
%%abbrev meval : mprog -> label -> mvalue -> type = [q] [l] [r] msteps q (mframes/final z) l rstack/nil r.


\begin{judgement}{\meval{\mprog}{\mctrl}{\addr}{\mvals}{\mval}}
{executing the program $\mprog$ in the state $\tup{\mctrl \tupsep \addr \tupsep \mvals}$ yields $\mval$}
%
\begin{prooftree}
  \rightl{$(\mprog(\addr) = \mhalt)$}
  \ax{\meval{\mprog}{\stknil}{\addr}{[\mval]}{\mval}}
\end{prooftree}

\begin{prooftree}
  \ninf{\mexec{\minst}{\mctrl}{\addr}{\mvals}{\mctrl'}{\addr'}{\mvals'}}
  \ninf{\meval{\mprog}{\mctrl'}{\addr'}{\mvals'}{\mval}}
	\rightl{$(\mprog(\addr) = \minst)$}
  \binf{\meval{\mprog}{\mctrl}{\addr}{\mvals}{\mval}}
\end{prooftree}
%
\end{judgement}
where $\mprog(\addr)$ denotes the $\addr$'th instruction of the program $\mprog$.

As an abbreviation for complete execution, let \mevalfinal{\mprog}{\addr}{\mval} denote \meval{\mprog}{[\fr{\envnil}{0}]}{\addr}{\stknil}{\mval}.
\mevalfinal{\mprog}{\addr}{\mval} can then be read as ``$\mprog$ starting at $\addr$ evaluates fully to $\mval$''.

% halt is always at index 0
