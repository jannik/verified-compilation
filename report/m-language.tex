\section{The \textnormal{\mlang} Language}

The distinguishing feature of \mlang is that the program is fully linearised and is not consumed during execution.
Rather, instructions are fetched from a program store which is kept static.
Like \slang, \mlang has abstract stack machine semantics.

\subsection{Syntax}

Let $\addr$ denote program addresses (natural numbers).
We define machine instructions $\minst$ and programs $\mprog$:
\begin{align*}
  \minst &\defi \mpushnum{\nat} \alt \mpushvar{\bvar} \alt \mpushclos{\addr} \alt \mcall{\addr} \alt \minc \alt \mret \alt \mhalt \\
  \mprog &\defi \mend \alt \minst \mseq \mprog
\end{align*}
Note that the address in the instruction $\mcall{\addr}$ is the return address.
And let $\mprog_1 \mconcat \mprog_2$ denote the concatenation of programs $\mprog_1$ and $\mprog_2$.

The abundance of syntax indicating termination warrants an explanation.
\texttt{ret} is for returning from a function call.
\texttt{halt} is for ending the entire program (to treat all stack frames uniformly, the top-level also ends with a \texttt{ret} instruction).
\texttt{end} signifies the end of the program store --- it should never be reached during execution.


\subsection{Semantics}

We define values $\mval$, environments $\menv$, control stacks $\mctrl$, and value stacks $\mvals$:
\begin{align*}
  \mval &\defi \n{\nat} \alt \cl{\menv}{\addr} \\
  \menv &\defi \envnil \alt \menv \envcons \mval \\
  \mctrl &\defi \stknil \alt \mctrl \stkcons \fr{\menv}{\addr} \\
  \mvals &\defi \stknil \alt \mvals \stkcons \mval
\end{align*}

As usual, we need a judgement for variable lookup:

\begin{judgement}{\mlook{\menv}{\bvar}{\mval}}

\begin{prooftree}
  \ax{\slook{\menv \envcons \mval}{\z}{\mval}}
\end{prooftree}

\begin{prooftree}
  \ninf{\slook{\menv}{\bvar}{\mval}}
  \uinf{\slook{\menv \envcons \mval'}{\suc{\bvar}}{\mval}}
\end{prooftree}

\end{judgement}

We then define judgements for execution:

\begin{judgement}{\mexec{\minst}{\mctrl}{\addr}{\mvals}{\mctrl'}{\addr'}{\mvals'}}

\begin{prooftree}
  \ax{\mexec{\mpushnum{\nat}}{\mctrl}{\addr}{\mvals}{\mctrl}{\addr + 1}{\mvals \stkcons \n{\nat}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\mlook{\menv}{\bvar}{\mval}}
  \uinf{\mexec{\mpushvar{\bvar}}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr}{\mvals}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr + 1}{\mvals \stkcons \mval}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{\mpushclos{\addr'}}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr}{\mvals}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr + 1}{\mvals \stkcons \cl{\menv}{\addr'}}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{\mcall{\addrret}}{\mctrl}{\addr}{\mvals \stkcons \cl{\menv'}{\addr'} \stkcons \mval}{\mctrl \stkcons \fr{\menv' \envcons \mval}{\addrret}}{\addr'}{\mvals}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{\minc}{\mctrl}{\addr}{\mvals \stkcons \n{\nat}}{\mctrl}{\addr + 1}{\mvals \stkcons \n{\nat + 1}}}
\end{prooftree}

\begin{prooftree}
  \ax{\mexec{\mret}{\mctrl \stkcons \fr{\menv}{\addrret}}{\addr}{\mvals}{\mctrl}{\addrret}{\mvals}}
\end{prooftree}

(No rule for \texttt{halt}!)

\end{judgement}

% maybe require judgement to finish execution, assuming we never concat derivations
\begin{judgement}{\msteps{\mprog}{\mctrl}{\addr}{\mvals}{\mctrl'}{\addr'}{\mvals'}}

\begin{prooftree}
  \ax{\msteps{\mprog}{\mctrl}{\addr}{\mvals}{\mctrl}{\addr}{\mvals}}
\end{prooftree}

\begin{prooftree}
  \ninf{\mexec{\minst}{\mctrl}{\addr}{\mvals}{\mctrl''}{\addr''}{\mvals''}}
  \ninf{\msteps{\mprog}{\mctrl''}{\addr''}{\mvals''}{\mctrl'}{\addr'}{\mvals'}}
	\rightl{$(\mprog(\addr) = \minst)$}
  \binf{\msteps{\mprog}{\mctrl}{\addr}{\mvals}{\mctrl'}{\addr'}{\mvals'}}
\end{prooftree}

\end{judgement}

where $\mprog(\addr)$ denotes the $\addr$'th instruction of the program $\mprog$.

As an abbreviation for complete execution, let \meval{\mprog}{\addr}{\mval} denote \msteps{\mprog}{[\fr{\envnil}{0}]}{\addr}{\stknil}{\stknil}{\addr'}{[\mval]} with $\mprog(\addr') = \mhalt$.
[Are side conditions okay for abbreviations? This used to be a judgement with a single rule.]

%
%\begin{judgement}{\meval{\mprog}{\addr}{\mval}}
%
%
%\begin{prooftree}
  %\ninf{\msteps{\mprog}{[\fr{\envnil}{0}]}{\addr}{\stknil}{\stknil}{\addr'}{[\mval]}}
  %\rightl{$(\mprog(\addr') = \mhalt)$}
  %\uinf{\meval{\mprog}{\addr}{\mval}}
%\end{prooftree}
%
%\end{judgement}