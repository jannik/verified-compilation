\section{Introduction}
Compilers are notoriosly difficult to implement correctly.
For instance, as shown by Eide and Regehr in \cite{EideRegehr08} many C compilers (including GCC and LLVM) miscompile code involving volatile memory access.
This is particularly worrying because it diminishes the value of static analysis on source programs, which is typically simpler than analysing the generated machine code.
For most programs this is not a big problem because the source code contains many errors already, but for safety-critical applications the importance of a correct compiler is much greater.

% something about this: http://blog.regehr.org/archives/503

There are several ways of achieving the correctness of a compiler.
One way is through extensive testing, though in practice this is never quite sufficient to be rid of all errors.
Another way is to prove the correctness of the compiler.
The latter option is the subject matter at hand.
Using a dependently typed language it is possible to encode statements and their proofs in the type system.

% A little intro to LF, Elf and Twelf.. and how they differ from other logics and proof assistants.
We use the Twelf proof assistant, which is based on the LF logical framework [citation Pfenning].
Twelf is dependently typed, but it is limited in other respects such as only being able to prove $\Pi_2^0$ ($\forall \exists$) theorems. [cite How to Believe a Twelf Proof?]
Hence, for a given statement it is not a priori clear whether Twelf is capable of proving (or even stating) it, even if a proof exists on paper.
On the other hand, Twelf has higher-order abstract syntax offering advantages when dealing with binders.

Our aim is to investigate the feasibility of implementing a verified compiler using Twelf.


\section{Previous Work}

The main work in this area is the CompCert C verified compiler, a ``high-assurance compiler for almost all of the ISO C90 / ANSI C language, generating efficient code for the PowerPC, ARM and x86 processors'' [cite http://compcert.inria.fr/].
It targets embedded programming and is written almost entirely in Coq (exceptions being the parser and the assembly code pretty-printer).
Notably, the compiler implements non-trivial optimisations such as inlining.

The same framework has been used to make a compiler for mini-ML with progress towards verified garbage collection [cite Xavier Leroy].

Another project similarly achieves verified compilation for an ML-like language using Coq [cite Adam Chlipala].
The focus is on maintainability of the compiler, in particular using parameterised higher-order abstract syntax, while memory management is largely ignored.

% Not too much higher-order previously.

% Mention Pfenning.
% Non-totality.
% Concrete representations.
% Explain how we expand on previous work.


\section{Overview}

Our source language, \hlang, is a simple higher-order functional language with substitution semantics.
The target language, \mlang, is a machine-like language featuring linearised programs with abstract stack machine semantics.
The translation employs two intermediate languages --- \blang and \slang --- to more clearly separate the different aspects of the equivalence between \hlang and \mlang.

From \hlang to \blang, named variables are turned into De Bruijn indices and closures are represented explicitly.
Then from \blang to \slang, the syntax is partially linearised and the semantics become based on an abstract machine.
And finally from \slang to \mlang, the entire program is linearised.

For each language in order we present its syntax and semantics, followed by the translation from the previous language.
We then argue that the translation is total and preserves the semantics.
The final result is a translation from \hlang to \mlang such that a \hlang program evaluates to some value if and only if the generated \mlang program evaluates to that same value.

In general, each section will include details about the Twelf mechanisation whenever relevant.
Only the parts that differ from the paper version will be commented --- most of the Twelf code corresponds straightforwardly to it.
The entire code is included as Appendix~\ref{sec:code}.

% something about how most of our effort was spent on coming up with useful generalisation of soundness+completeness.
% the proofs are generally not that complicated, excepting totality of hoas-bruijn.
% this sort of explains away the need for long explanations of the equivalence proofs in later sections


% \section{Overview of Mechanisation}

% [ok title? placement?]
% The Twelf implementation comprises x files [perhaps give a list, a sort of table of contents for the code].
% For each language, the syntax and semantics are defined in ...
