\section{Introduction}
Compilers are notoriously difficult to implement correctly.
For instance, as shown by Eide and Regehr in \cite{EideRegehr08} many C compilers (including GCC and LLVM) miscompile code involving volatile memory access.
This is particularly worrying because it diminishes the value of static analysis on source programs, which is typically simpler than analysing the generated machine code.
For most programs this is not a big problem because the source code contains many errors already, but for safety-critical applications the importance of a correct compiler is much greater.

There are several ways of achieving the correctness of a compiler.
One way is through extensive testing, though in practice this is never quite sufficient to be rid of all errors.
Another way is to prove the correctness of the compiler.
The latter option is the subject matter at hand.
Using a dependently typed language it is possible to encode statements and their proofs in the type system.

% A little intro to LF, Elf and Twelf.. and how they differ from other logics and proof assistants.
We use the Twelf proof assistant, which is based on the LF logical framework [citation Pfenning].
Twelf is dependently typed, but it is limited in other respects such as only being able to prove $\Pi_2^0$ ($\forall \exists$) theorems. [cite How to Believe a Twelf Proof?]
Hence, for a given statement it is not a priori clear whether Twelf is capable of proving (or even stating) it, even if a proof exists on paper.
On the other hand, Twelf has higher-order abstract syntax offering advantages when dealing with binders.

Our aim is to investigate the feasibility of implementing a verified compiler using Twelf.


\section{Previous Work}

The main work in this area is the CompCert C verified compiler, a ``high-assurance compiler for almost all of the ISO C90 / ANSI C language, generating efficient code for the PowerPC, ARM and x86 processors'' (see \cite{CompCert16}).
It targets embedded programming and is written almost entirely in Coq (exceptions being the parser and the assembly code pretty-printer).
Notably, the compiler implements non-trivial optimisations such as inlining.
A study, \cite{Yang11}, found code generation errors in all C compilers tested, except for the verified parts of CompCert.

The same framework has been used to make a compiler for mini-ML with progress towards verified garbage collection [cite Xavier Leroy].
% http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/24/slides/xavier.pdf
% http://pauillac.inria.fr/~dargaye/publications.html

Another project similarly achieves verified compilation for an ML-like language using Coq [cite Adam Chlipala].
The focus is on maintainability of the compiler, in particular using parameterised higher-order abstract syntax, while memory management is largely ignored.

Overall, however, the focus has mainly been on first-order imperative languages such as C.

Using Twelf there are not many prior examples of verified compilation.
The main results are found in \cite[ch. 6]{Pfenning01}.
% Talk about how little Pfenning did and that it was non-total.
% Mention concrete representations guy.

[Should we explain how we expand on previous work here?]


\section{Overview}

Our source language, \hlang, is a simple higher-order functional language with substitution semantics.
The target language, \mlang, is a machine-like language featuring linearised programs with abstract stack machine semantics.
The translation employs two intermediate languages --- \blang and \slang --- to more clearly separate the different aspects of the equivalence between \hlang and \mlang.

From \hlang to \blang, named variables are turned into De Bruijn indices and closures are represented explicitly.
Then from \blang to \slang, the syntax is partially linearised and the semantics become based on an abstract machine.
And finally from \slang to \mlang, the entire program is linearised.

For each language in order we present its syntax and semantics, followed by the translation from the previous language.
We then argue that the translation is total and preserves the semantics.
The final result is a translation from \hlang to \mlang such that a \hlang program evaluates to some value if and only if the generated \mlang program evaluates to that same value.

In general, each section will include details about the Twelf mechanisation whenever relevant.
Only the parts that differ from the paper version will be commented --- most of the Twelf code corresponds straightforwardly to it.
The entire code is included as Appendix~\ref{sec:code}.

The main challenge in this type of mechanisation is formulating lemmas to generalise the theorems about semantics-preservation.
This involves finding the right invariants describing the relation between execution states.
With the appropriate lemma in hand, the proof is usually fairly straightforward.
Hence, we shall take the liberty to omit explanations of the implementation in most instances.
