\subsection{Translation}

% We define the type of correspondence contexts $\hbctx$.

% \begin{align*}
%   \hbctx &\defi \ctxnil \alt \hbctx_1 \ctxcons \cor{\bval}{\var}
% \end{align*}

% consider calling it 'extraction' or similar, or 'correspondence' (probably not) instead

Before giving the translation judgement, we want to point out that there are several workable ways of implementing translation.
The most ``obvious'' solution is to keep an ordered list of free variables (say $\Gamma$) such that each variable's position indicates its De Bruijn index.
We would have a judgement like the following (omitting the cases that are just straightforward induction).



\begin{judgement}{\blook{\Gamma}{\bvar}{\var}}



(Suitable rules to find the $\bvar$'th element of $\Gamma$.)



\end{judgement}

\begin{judgement}{\trahbfaux{\Gamma}{\hexp}{\bexp}}

\begin{prooftree}
  \ninf{\blook{\Gamma}{\bvar}{\var}}
  \uinf{\trahbfaux{\Gamma}{\var}{\bvar}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahbfaux{\Gamma \envcons \var}{\hexp_1}{\bexp_1}}
  \rightl{($\var \notin \Gamma$)}
  \uinf{\trahbfaux{\Gamma}{\lam{\var}{\hexp_1}}{\blam{\bexp_1}}}
\end{prooftree}

\end{judgement}

Note that the side condition $\var \notin \Gamma$ is necessary to prevent shadowed variables from being used giving rise to ``translations'' like \trahbfaux{\envnil}{\lam{\var}{\lam{\var}{\var}}}{\blam{\blam{(\suc{\z})}}}.
However, there are still two problems with the translation judgement presented above.

Firstly, while every closed $\bexp$ allows us to find some $\hexp$ such that \trahbfaux{\envnil}{\hexp}{\bexp} (we will neither need nor prove this fact), it is not immediately clear that the translation is total in the left-to-right direction, i.e. that every closed $\hexp$ has a corresponding $\bexp$.
In fact, this property does not hold!
Consider $\hexp = \lam{\var}{\lam{\var}{\n{0}}}$; the best attempt at a translation would be something like:
\begin{prooftree}
	\prem{\vdots}{\trahbfaux{\envnil \envcons \var \envcons \var}{\n{0}}{\n{0}}}
  \rightl{($\var \notin (\envnil \envcons \var)$)}
  \uinf{\trahbfaux{\envnil \envcons \var}{\lam{\var}{\n{0}}}{\blam{\n{0}}}}
  \rightl{($\var \notin \envnil$)}
  \uinf{\trahbfaux{\envnil}{\lam{\var}{\lam{\var}{\n{0}}}}{\blam{\blam{\n{0}}}}}
\end{prooftree}
However, the side condition $\var \notin (\envnil \envcons \var)$ is blatantly false.
In general, nested $\lambda$'s using the same variable name will run into this problem.

Hence, we can at best hope that there is always some alpha-equivalent expression which is translatable.
For this reason using a $\rhd$ is misleading and we shall instead use the notation \trahb{\hbctx}{\Gamma}{\bexp}{\hexp} to accurately depict in which direction the relation \emph{is} total (again, assuming closed expressions).

Secondly, investigating this approach we found that proving soundness and completeness was doable but cumbersome: the invariant involves a complex relationship between $\benv$, $\Gamma$ and the free variables in scope.
There is an easier way, though, adapted from \cite[p. 150]{Pfenning01}.
The idea is to weaken the separation between semantics and translation and use the environment type $\benv$ instead of just a list of variables.
For this to work we need a notion of hypothetical values (after all, we are not executing the program so no concrete values will arise) so we will have to use an extended from of $\benv$ that can also contain variables.
This has little effect if all we want to do is translate programs, but it turns out that this approach affords a simple invariant for soundness and completeness.

Formally, we define a new type of values and environments as follows:
\begin{align*}
  \bvalext &\defi \bval \alt \var \\
  \benvext &\defi \envnil \alt \benvext \envcons \bvalext
\end{align*}
We will consider $\benv$ to be a subtype of $\benvext$ in the natural way.
The set of variables occuring in $\benvext$ will be denoted by $\vars(\benvext)$.

That being said, the translation judgement is as follows.



\begin{judgement}{\trahb{\hbctx}{\benvext}{\bexp}{\hexp}}

\begin{prooftree}
  \leftl{\rulename{T-Num} :}
  \ax{\trahb{\hbctx}{\benvext}{\n{\nat}}{\n{\nat}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\blook{\benvext}{\bvar}{\bval}}
  \ninf{\corhb{\hbctx}{\bval}{\hexp}}
  \leftl{\rulename{T-Var} :}
  \binf{\trahb{\hbctx}{\benvext}{\bvar}{\hexp}}
\end{prooftree}

\begin{prooftree}
	\ninf{\trahb{\hbctx}{\benvext \envcons \var}{\bexp_1}{\hexp_1}}
  \rightl{($\var \notin \benvext$)}
  \leftl{\rulename{T-Lam} :}
  \uinf{\trahb{\hbctx}{\benvext}{\blam{\bexp_1}}{\lam{\var}{\hexp_1}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\hbctx}{\benvext}{\bexp_1}{\hexp_1}}
  \ninf{\trahb{\hbctx}{\benvext}{\bexp_2}{\hexp_2}}
	\leftl{\rulename{T-App} :}
  \binf{\trahb{\hbctx}{\benvext}{\bapp{\bexp_1}{\bexp_2}}{\app{\hexp_1}{\hexp_2}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\hbctx}{\benvext}{\bexp_1}{\hexp_1}}
	\leftl{\rulename{T-Suc} :}
  \uinf{\trahb{\hbctx}{\benvext}{\bsuc{\bexp_1}}{\hsuc{\hexp_1}}}
\end{prooftree}

\end{judgement}

It uses a correspondence relation between values and expressions in canonical form:



\begin{judgement}{\corhb{\hbctx}{\bval}{\hexp}}

\begin{prooftree}
  \leftl{\rulename{C-Var} :}
  \ax{\corhb{\Theta}{\var}{\var}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{C-Num} :}
  \ax{\corhb{\hbctx}{\n{\nat}}{\n{\nat}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\hbctx}{\benv}{\blam{\bexp}}{\lam{\var}{\hexp}}}
  \leftl{\rulename{C-Fun} :}
  \uinf{\corhb{\hbctx}{\cl{\benv}{\bexp}}{\lam{\var}{\hexp}}}
\end{prooftree}

\end{judgement}

The fact that \rulename{C-Fun} uses a plain $\benv$ is intentional: we do not allow \hlang variables to occur inside \blang closures.
