\subsection{Translation}
We want an effective procedure that given any \hlang expression $\hexp$ finds a \blang expression $\bexp$ such that $\hexp$ evaluates to $\n{\nat}$ if and only if $\bexp$ evaluates to $\n{\nat}$ --- in other words, a translation from \hlang to \blang that preserves semantics.
There is little doubt what a given $\hexp$ should translate to since each variable should simply be replaced with its De Bruijn index.
However, specifying this in general is not trivial and there are several possible solutions.
We want to make the proof that semantics is preserved as easy as possible.
To this end we adapt Pfenning's approach \cite[p. 150]{Pfenning01}.
For any variable $\var$ representing a \hlang expression we will consider $\hbvar$ to be a variable representing a \blang value.
We will need to consider environments containing a number of these variables:
\begin{align*}
  \benvext &\defi \envnil \alt \benvext \envcons \hbvar
\end{align*}
The set of variables occuring in $\benvext$ at least once will be denoted by $\vars(\benvext)$.
To talk about objects that are either ordinary values or variable values we define their disjoint union:
\begin{align*}
  \bvalext &\defi \bval \alt \hbvar
\end{align*}

The \blook{\benv}{\bvar}{\bval} judgement can be extended to look through an $\benvext$ first:

\begin{judgement}{\blookext{\benv}{\benvext}{\bvar}{\bvalext}}
{searching through $\benvext$ and then $\benv$ yields $\bval$ at index $\bvar$}
%
\begin{prooftree}
  \leftl{\rulename{Tv-Here} :}
  \ax{\blookext{\benv}{\benvext \envcons \var}{\z}{\varext}}
\end{prooftree}

\begin{prooftree}
  \ninf{\blookext{\benv}{\benvext}{\bvar}{\bvalext}}
  \rightl{($\bvalext \neq \var$)}
  \leftl{\rulename{Tv-There} :}
  \uinf{\blookext{\benv}{\benvext \envcons \varext}{\suc{\bvar}}{\bvalext}}
\end{prooftree}

\begin{prooftree}
  \ninf{\blook{\benv}{\bvar}{\bval}}
  \leftl{\rulename{Tv-Value} :}
  \uinf{\blookext{\benv}{\envnil}{\bvar}{\bval}}
\end{prooftree}
%
\end{judgement}

Given a $\bexp$ and an $\benvext$ we can consider extracting some $\hexp$, informally speaking by substituting $\benvext$ in $\bexp$ and finding corresponding \hlang values.
% rephrase
This can be expressed in judgemental form as follows.

\begin{judgement}{\trahb{\benv}{\benvext}{\bexp}{\hexp}}
{in the environment $\benvboth{\benv}{\benvext}$, $\hexp$ is the extraction of $\bexp$}
%
\begin{prooftree}
  \leftl{\rulename{T-Num} :}
  \ax{\trahb{\benv}{\benvext}{\n{\nat}}{\n{\nat}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\blookext{\benv}{\benvext}{\bvar}{\bvalext}}
  \ninf{\corhb{\benv}{\bvalext}{\hexp}}
  \leftl{\rulename{T-Var} :}
  \binf{\trahb{\benv}{\benvext}{\bvar}{\hexp}}
\end{prooftree}

\begin{prooftree}
	\ninf{\trahb{\benv}{\benvext \envcons \varext}{\bexp_1}{\hexp_1}}
  \leftl{\rulename{T-Lam} :}
  \uinf{\trahb{\benv}{\benvext}{\blam{\bexp_1}}{\lam{\var}{\hexp_1}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\benv}{\benvext}{\bexp_1}{\hexp_1}}
  \ninf{\trahb{\benv}{\benvext}{\bexp_2}{\hexp_2}}
	\leftl{\rulename{T-App} :}
  \binf{\trahb{\benv}{\benvext}{\bapp{\bexp_1}{\bexp_2}}{\app{\hexp_1}{\hexp_2}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\benv}{\benvext}{\bexp_1}{\hexp_1}}
	\leftl{\rulename{T-Suc} :}
  \uinf{\trahb{\benv}{\benvext}{\bsuc{\bexp_1}}{\hsuc{\hexp_1}}}
\end{prooftree}
%
\end{judgement}

It uses a correspondence relation between values and expressions.
Note that the rule for functions uses an empty $\benvext$.

\begin{judgement}{\corhb{\benv}{\bvalext}{\hexp}}
{$\hexp$ corresponds to $\bvalext$}
%
\begin{prooftree}
  \leftl{\rulename{C-Var} :}
  \ax{\corhb{}{\varext}{\var}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{C-Num} :}
  \ax{\corhb{}{\n{\nat}}{\n{\nat}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\benv}{\envnil}{\blam{\bexp}}{\lam{\var}{\hexp}}}
  \leftl{\rulename{C-Fun} :}
  \uinf{\corhb{}{\cl{\benv}{\bexp}}{\lam{\var}{\hexp}}}
\end{prooftree}
%
\end{judgement}

\Twelf
We do not explicitly consider a different type of environment where variables can occur --- instead, we consider worlds where hypothetical values exist.
What is just a variable $\var$ during the translation on paper will manifest itself both as a hypothetical \hlang expression and as a hypothetical \blang value in Twelf.
Hence, we must make sure that they correspond giving rise to the following block:
\input{code-trans-hb-block}
The correspondence hypothesis is the Twelf analogue of the \rulename{C-Var} rule.

Why is the judgement an extraction and why is the $\rhd$ not a $\lhd$?
The reason is that it is only deterministic when viewed from right to left (considering a fixed $\benvext$).
For example in the environment $\envnil \envcons \n{0}$ both $\blam{\z}$ and $\blam{\n{0}}$ extract to $\lam{\var}{\n{0}}$.
In the general case we cannot view it as a function from $\hexp$ to $\bexp$.

Even so we still want to translate!
Thus, we proceed to argue that every closed $\hexp$ is the extraction of some $\bexp$.
