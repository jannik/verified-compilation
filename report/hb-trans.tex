\subsection{Translation}
We want an effective procedure that given any \hlang expression $\hexp$ finds a \blang expression $\bexp$ such that $\hexp$ evaluates to $\n{\nat}$ if and only if $\bexp$ evaluates to $\n{\nat}$ --- in other words, a translation from \hlang to \blang that preserves semantics.
There is little doubt what a given $\hexp$ should translate to since each variable should simply be replaced with its De Bruijn index.
However, specifying this in general is not trivial and there are several possible solutions.
We want to make the proof that semantics is preserved as easy as possible.
To this end we adapt Pfenning's approach \cite[p. 150]{Pfenning01} and define a type of environments containing a number of variables followed by a number of \blang values:
\begin{align*}
  \benvext &\defi \benv \alt \benvext \envcons \var
\end{align*}
The set of variables occuring in $\benvext$ at least once will be denoted by $\vars(\benvext)$.

The \blook{\benv}{\bvar}{\bval} judgement can be extended to work with $\benvext$:

\begin{judgement}{\blookext{\benvext}{\bvar}{\bval}}

\begin{prooftree}
  \leftl{\rulename{Tv-Here} :}
  \ax{\blookext{\benvext \envcons \var}{\z}{\var}}
\end{prooftree}

\begin{prooftree}
  \ninf{\blookext{\benvext}{\bvar}{\bval}}
  \rightl{($\bval \neq \var$)}
  \leftl{\rulename{Tv-There} :}
  \uinf{\blookext{\benvext \envcons \var}{\suc{\bvar}}{\bval}}
\end{prooftree}

\begin{prooftree}
  \ninf{\blook{\benv}{\bvar}{\bval}}
  \leftl{\rulename{Tv-Value} :}
  \uinf{\blookext{\benv}{\bvar}{\bval}}
\end{prooftree}

\end{judgement}

Given a $\bexp$ and an $\benvext$ we can consider extracting some $\hexp$, informally speaking by substituting $\benvext$ in $\bexp$ and finding corresponding \hlang values.
% rephrase
This can be expressed in judgemental form as follows.

\begin{judgement}{\trahb{\hbctx}{\benvext}{\bexp}{\hexp}}

\begin{prooftree}
  \leftl{\rulename{T-Num} :}
  \ax{\trahb{\hbctx}{\benvext}{\n{\nat}}{\n{\nat}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\blookext{\benvext}{\bvar}{\bvalext}}
  \ninf{\corhb{\hbctx}{\bvalext}{\hexp}}
  \leftl{\rulename{T-Var} :}
  \binf{\trahb{\hbctx}{\benvext}{\bvar}{\hexp}}
\end{prooftree}

\begin{prooftree}
	\ninf{\trahb{\hbctx}{\benvext \envcons \var}{\bexp_1}{\hexp_1}}
  \leftl{\rulename{T-Lam} :}
  \uinf{\trahb{\hbctx}{\benvext}{\blam{\bexp_1}}{\lam{\var}{\hexp_1}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\hbctx}{\benvext}{\bexp_1}{\hexp_1}}
  \ninf{\trahb{\hbctx}{\benvext}{\bexp_2}{\hexp_2}}
	\leftl{\rulename{T-App} :}
  \binf{\trahb{\hbctx}{\benvext}{\bapp{\bexp_1}{\bexp_2}}{\app{\hexp_1}{\hexp_2}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\hbctx}{\benvext}{\bexp_1}{\hexp_1}}
	\leftl{\rulename{T-Suc} :}
  \uinf{\trahb{\hbctx}{\benvext}{\bsuc{\bexp_1}}{\hsuc{\hexp_1}}}
\end{prooftree}

\end{judgement}

It uses a correspondence relation between values and expressions.
Note that the rule for functions uses a regular $\benv$.

\begin{judgement}{\corhb{\hbctx}{\bvalext}{\hexp}}

\begin{prooftree}
  \leftl{\rulename{C-Var} :}
  \ax{\corhb{\Theta}{\var}{\var}}
\end{prooftree}

\begin{prooftree}
  \leftl{\rulename{C-Num} :}
  \ax{\corhb{\hbctx}{\n{\nat}}{\n{\nat}}}
\end{prooftree}

\begin{prooftree}
  \ninf{\trahb{\hbctx}{\benv}{\blam{\bexp}}{\lam{\var}{\hexp}}}
  \leftl{\rulename{C-Fun} :}
  \uinf{\corhb{\hbctx}{\cl{\benv}{\bexp}}{\lam{\var}{\hexp}}}
\end{prooftree}

\end{judgement}

\Twelf
We do not explicitly consider a different type of environment where variables can occur --- instead, we consider worlds where hypothetical values exist.
What is just a variable $\var$ during the translation on paper will manifest itself both as a hypothetical \hlang expression and as a hypothetical \blang value in Twelf.
Hence, we must make sure that they correspond giving rise to the following block:
\input{code-trans-hb-block}
The correspondence hypothesis is the Twelf analogue of the \rulename{C-Var} rule.

Why is the judgement an extraction and why is the $\rhd$ not a $\lhd$?
The reason is that it is only deterministic when viewed from right to left (considering a fixed $\benvext$).
For example in the environment $\envnil \envcons \n{0}$ both $\blam{\z}$ and $\blam{\n{0}}$ extract to $\lam{\var}{\n{0}}$.
In the general case we cannot view it as a function from $\hexp$ to $\bexp$.

Even so we still want to translate!
Thus, we proceed to argue that every closed $\hexp$ is the extraction of some $\bexp$.
